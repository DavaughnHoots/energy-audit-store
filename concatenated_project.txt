
----- Start of index.html -----

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Energy Efficient Store</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

----- End of index.html -----



----- Start of postcss.config.js -----

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


----- End of postcss.config.js -----



----- Start of project_tree.txt -----

energy-audit-store
├── .claudesync
│   └── config.local.json
├── .git
│   ├── hooks
│   ├── info
│   │   └── exclude
│   ├── objects
│   │   ├── info
│   │   └── pack
│   │       └── pack-54ba542e1e3fcccf997ea45f5d0cd8da616010c3.rev
│   ├── refs
│   │   ├── heads
│   │   │   └── main
│   │   ├── remotes
│   │   │   └── origin
│   │   │       └── HEAD
│   │   └── tags
│   ├── config
│   ├── description
│   ├── FETCH_HEAD
│   ├── HEAD
│   ├── index
│   └── packed-refs
├── .trunk
│   ├── actions
│   │   ├── trunk-cache-prune
│   │   ├── trunk-share-with-everyone
│   │   ├── trunk-single-player-auto-on-upgrade
│   │   ├── trunk-single-player-auto-upgrade
│   │   └── trunk-whoami
│   ├── notifications
│   ├── out
│   ├── plugins
│   ├── tools
│   ├── .claudeignore
│   └── .gitignore
├── backend
│   ├── src
│   │   ├── config
│   │   │   ├── cache.ts
│   │   │   ├── database.ts
│   │   │   ├── email.ts
│   │   │   └── logger.ts
│   │   ├── middleware
│   │   │   ├── auth.ts
│   │   │   ├── security.ts
│   │   │   └── validators.ts
│   │   ├── routes
│   │   │   ├── analytics.ts
│   │   │   ├── auth.ts
│   │   │   ├── emailVerification.ts
│   │   │   ├── energyAudit.ts
│   │   │   ├── products.ts
│   │   │   ├── recommendations.ts
│   │   │   └── userSettings.ts
│   │   ├── services
│   │   │   ├── analyticsService.ts
│   │   │   ├── emailService.ts
│   │   │   ├── EnergyAuditService.ts
│   │   │   ├── notificationsService.ts
│   │   │   ├── productDataService.ts
│   │   │   ├── productService.ts
│   │   │   ├── recommendationService.ts
│   │   │   ├── searchService.ts
│   │   │   ├── userAuthService.ts
│   │   │   └── userService.ts
│   │   ├── types
│   │   │   ├── analytics.ts
│   │   │   ├── energyAudit.ts
│   │   │   ├── notifications.ts
│   │   │   └── product.ts
│   │   ├── validators
│   │   │   ├── homeAudit.validator.ts
│   │   │   └── product.validator.ts
│   │   └── server.ts
│   ├── .env
│   ├── package-lock.json
│   └── package.json
├── public
│   ├── data
│   │   └── products.csv
│   └── vite.svg
├── src
│   ├── assets
│   │   └── react.svg
│   ├── components
│   │   ├── audit
│   │   │   └── EnergyAuditForm.tsx
│   │   ├── auth
│   │   │   ├── AuthService.ts
│   │   │   ├── SignIn.tsx
│   │   │   └── SignUp.tsx
│   │   ├── layout
│   │   │   ├── Footer.tsx
│   │   │   └── Header.tsx
│   │   ├── products
│   │   │   ├── EnergySavingsCard.tsx
│   │   │   ├── ProductDetailHeader.tsx
│   │   │   └── ProductSpecifications.tsx
│   │   └── ui
│   │       ├── alert.tsx
│   │       └── badge.tsx
│   ├── config
│   │   └── api.ts
│   ├── context
│   │   └── SettingsContext.tsx
│   ├── hooks
│   │   └── useProducts.ts
│   ├── lib
│   │   └── utils.ts
│   ├── pages
│   │   ├── EducationPage.tsx
│   │   ├── EnergyAuditPage.tsx
│   │   ├── ProductDetailPage.tsx
│   │   ├── ProductsPage.tsx
│   │   └── UserSettingsPage.tsx
│   ├── templates
│   │   └── email-verification.html
│   ├── App.css
│   ├── App.tsx
│   ├── file_tree.txt
│   ├── index.css
│   ├── main.tsx
│   └── vite-env.d.ts
├── .env
├── .gitignore
├── database_setup.sql
├── eslint.config.js
├── filetreegenerator.py
├── index.html
├── package-lock.json
├── package.json
├── postcss.config.js
├── project_tree.txt
├── README.md
├── tailwind.config.js
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts


----- End of project_tree.txt -----



----- Start of tailwind.config.js -----

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

----- End of tailwind.config.js -----



----- Start of vite.config.ts -----

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
    // Exclude problematic Node.js modules
    mainFields: ['browser', 'module', 'main'],
    modules: ['node_modules'],
  },
  build: {
    rollupOptions: {
      external: [
        'aws-sdk',
        'mock-aws-s3',
        'nock',
        '@mapbox/node-pre-gyp',
      ],
    },
  },
  optimizeDeps: {
    exclude: ['@mapbox/node-pre-gyp', 'aws-sdk', 'mock-aws-s3', 'nock'],
  },
  server: {
    port: 5173,
    proxy: {
      // Proxy API requests to backend
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false,
      },
    },
  },
  define: {
    // Define global variables if needed
    'process.env': {},
  },
})

----- End of vite.config.ts -----



----- Start of backend\src\server.ts -----

// backend/src/server.ts

import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import helmet from 'helmet';
import { authService } from './services/auth/AuthService';

const app = express();

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:5173',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(cookieParser());
app.use(express.json());

// Auth routes with updated cookie settings
app.post('/auth/login', async (req, res) => {
  try {
    const { token, user } = await authService.loginUser(req.body.email, req.body.password);

    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
      path: '/'
    });

    res.json({ user });
  } catch (error) {
    res.status(401).json({ error: error.message });
  }
});

----- End of backend\src\server.ts -----



----- Start of backend\src\config\cache.ts -----

// backend/src/config/cache.ts

import Redis from 'ioredis';
import { appLogger } from './logger';

interface CacheConfig {
  host: string;
  port: number;
  password?: string;
  keyPrefix?: string;
  db?: number;
  enableTLS?: boolean;
}

interface CacheOptions {
  ttl?: number;  // Time to live in seconds
  tags?: string[];  // Cache tags for group invalidation
}

class CacheManager {
  private client: Redis;
  private readonly defaultTTL: number = 3600; // 1 hour default TTL
  private readonly keyPrefix: string;

  constructor(config: CacheConfig) {
    this.keyPrefix = config.keyPrefix || 'ees:';

    // Initialize Redis client with error handling
    this.client = new Redis({
      host: config.host,
      port: config.port,
      password: config.password,
      db: config.db || 0,
      keyPrefix: this.keyPrefix,
      retryStrategy: (times: number) => {
        const delay = Math.min(times * 50, 2000);
        return delay;
      },
      tls: config.enableTLS ? {
        rejectUnauthorized: false // For self-signed certificates in dev
      } : undefined,
      maxRetriesPerRequest: 3,
    });

    // Set up error handling
    this.client.on('error', (error) => {
      appLogger.error('Redis cache error:', { error: error.message });
    });

    this.client.on('connect', () => {
      appLogger.info('Redis cache connected');
    });
  }

  /**
   * Set a value in cache
   */
  async set(key: string, value: any, options: CacheOptions = {}): Promise<void> {
    try {
      const serializedValue = JSON.stringify(value);
      const ttl = options.ttl || this.defaultTTL;

      // Set the value with expiration
      await this.client.setex(key, ttl, serializedValue);

      // If tags are provided, add key to tag sets
      if (options.tags?.length) {
        await Promise.all(
          options.tags.map(tag =>
            this.client.sadd(`tag:${tag}`, key)
          )
        );
      }
    } catch (error) {
      appLogger.error('Cache set error:', { error: error.message, key });
      throw new CacheError('Failed to set cache value');
    }
  }

  /**
   * Get a value from cache
   */
  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await this.client.get(key);
      if (!value) return null;
      return JSON.parse(value) as T;
    } catch (error) {
      appLogger.error('Cache get error:', { error: error.message, key });
      throw new CacheError('Failed to get cache value');
    }
  }

  /**
   * Delete a value from cache
   */
  async del(key: string): Promise<void> {
    try {
      await this.client.del(key);
    } catch (error) {
      appLogger.error('Cache delete error:', { error: error.message, key });
      throw new CacheError('Failed to delete cache value');
    }
  }

  /**
   * Invalidate cache by tag
   */
  async invalidateByTag(tag: string): Promise<void> {
    try {
      // Get all keys for this tag
      const keys = await this.client.smembers(`tag:${tag}`);
      if (keys.length) {
        // Delete all keys and the tag set
        await Promise.all([
          this.client.del(...keys),
          this.client.del(`tag:${tag}`)
        ]);
      }
    } catch (error) {
      appLogger.error('Cache tag invalidation error:', { error: error.message, tag });
      throw new CacheError('Failed to invalidate cache by tag');
    }
  }

  /**
   * Check if a key exists in cache
   */
  async exists(key: string): Promise<boolean> {
    try {
      return await this.client.exists(key) === 1;
    } catch (error) {
      appLogger.error('Cache exists check error:', { error: error.message, key });
      throw new CacheError('Failed to check cache key existence');
    }
  }

  /**
   * Set multiple values in cache
   */
  async mset(items: Record<string, any>, ttl?: number): Promise<void> {
    try {
      const pipeline = this.client.pipeline();

      Object.entries(items).forEach(([key, value]) => {
        pipeline.setex(key, ttl || this.defaultTTL, JSON.stringify(value));
      });

      await pipeline.exec();
    } catch (error) {
      appLogger.error('Cache mset error:', { error: error.message });
      throw new CacheError('Failed to set multiple cache values');
    }
  }

  /**
   * Get multiple values from cache
   */
  async mget<T>(keys: string[]): Promise<(T | null)[]> {
    try {
      const values = await this.client.mget(keys);
      return values.map(value => value ? JSON.parse(value) : null);
    } catch (error) {
      appLogger.error('Cache mget error:', { error: error.message });
      throw new CacheError('Failed to get multiple cache values');
    }
  }

  /**
   * Clear entire cache
   */
  async clear(): Promise<void> {
    try {
      await this.client.flushdb();
    } catch (error) {
      appLogger.error('Cache clear error:', { error: error.message });
      throw new CacheError('Failed to clear cache');
    }
  }

  /**
   * Get cache info/stats
   */
  async getStats(): Promise<Record<string, any>> {
    try {
      const info = await this.client.info();
      return this.parseRedisInfo(info);
    } catch (error) {
      appLogger.error('Cache stats error:', { error: error.message });
      throw new CacheError('Failed to get cache stats');
    }
  }

  private parseRedisInfo(info: string): Record<string, any> {
    const stats: Record<string, any> = {};
    const lines = info.split('\n');

    lines.forEach(line => {
      const parts = line.split(':');
      if (parts.length === 2) {
        stats[parts[0]] = parts[1];
      }
    });

    return stats;
  }

  /**
   * Close cache connection
   */
  async close(): Promise<void> {
    await this.client.quit();
  }
}

// Custom error class for cache operations
export class CacheError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CacheError';
  }
}

// Create and export singleton instance
const cacheConfig: CacheConfig = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  keyPrefix: process.env.REDIS_KEY_PREFIX || 'ees:',
  db: parseInt(process.env.REDIS_DB || '0'),
  enableTLS: process.env.REDIS_TLS === 'true'
};

export const cacheManager = new CacheManager(cacheConfig);

----- End of backend\src\config\cache.ts -----



----- Start of backend\src\config\database.ts -----

// src/config/database.ts
import { Pool } from 'pg';

const pool = new Pool({
  user: process.env.DB_USER || 'postgres',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'EES',
  password: process.env.DB_PASSWORD || '',
  port: parseInt(process.env.DB_PORT || '5432')
});

export { pool };

----- End of backend\src\config\database.ts -----



----- Start of backend\src\config\email.ts -----

// backend/src/config/email.ts

import { createTransport, Transporter } from 'nodemailer';
import { readFileSync } from 'fs';
import handlebars from 'handlebars';
import path from 'path';

// Email configuration interface
export interface EmailConfig {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
  from: string;
  replyTo?: string;
}

// Email template interface
export interface EmailTemplate {
  subject: string;
  text: string;
  html: string;
}

// Email service configuration class
export class EmailConfiguration {
  private transporter: Transporter;
  private templates: Map<string, EmailTemplate>;
  private readonly templateDir: string;
  private readonly defaultFrom: string;
  private readonly defaultReplyTo: string;

  constructor(config: EmailConfig) {
    // Initialize nodemailer transporter
    this.transporter = createTransport({
      host: config.host,
      port: config.port,
      secure: config.secure,
      auth: config.auth,
      pool: true, // Use pooled connections
      maxConnections: 5,
      maxMessages: 100,
      // TLS configuration for security
      tls: {
        rejectUnauthorized: true, // Reject unauthorized TLS/SSL certificates
        minVersion: 'TLSv1.2'
      }
    });

    this.templates = new Map();
    this.templateDir = path.join(__dirname, '../templates/email');
    this.defaultFrom = config.from;
    this.defaultReplyTo = config.replyTo || config.from;

    // Load email templates on initialization
    this.loadTemplates();
  }

  // Load and compile email templates
  private loadTemplates(): void {
    const templateList = {
      'verification': 'email-verification',
      'password-reset': 'password-reset',
      'welcome': 'welcome-email',
      'audit-complete': 'audit-complete',
      'recommendation': 'recommendation',
      'savings-milestone': 'savings-milestone'
    };

    for (const [key, fileName] of Object.entries(templateList)) {
      try {
        const htmlTemplate = readFileSync(
          path.join(this.templateDir, `${fileName}.html`),
          'utf-8'
        );
        const textTemplate = readFileSync(
          path.join(this.templateDir, `${fileName}.txt`),
          'utf-8'
        );
        const configFile = require(path.join(this.templateDir, `${fileName}.json`));

        // Compile templates with Handlebars
        const compiledHtml = handlebars.compile(htmlTemplate);
        const compiledText = handlebars.compile(textTemplate);

        this.templates.set(key, {
          subject: configFile.subject,
          html: compiledHtml,
          text: compiledText
        });
      } catch (error) {
        console.error(`Failed to load email template ${key}:`, error);
        throw new Error(`Email template ${key} could not be loaded`);
      }
    }
  }

  // Get email transport configuration
  public getTransporter(): Transporter {
    return this.transporter;
  }

  // Get compiled template by name
  public getTemplate(name: string): EmailTemplate | undefined {
    return this.templates.get(name);
  }

  // Verify email configuration
  public async verifyConfiguration(): Promise<boolean> {
    try {
      await this.transporter.verify();
      return true;
    } catch (error) {
      console.error('Email configuration verification failed:', error);
      return false;
    }
  }

  // Get default sender address
  public getDefaultFrom(): string {
    return this.defaultFrom;
  }

  // Get default reply-to address
  public getDefaultReplyTo(): string {
    return this.defaultReplyTo;
  }
}

// Create and export singleton instance with environment variables
const emailConfig: EmailConfig = {
  host: process.env.EMAIL_HOST || 'smtp.example.com',
  port: parseInt(process.env.EMAIL_PORT || '587'),
  secure: process.env.EMAIL_SECURE === 'true',
  auth: {
    user: process.env.EMAIL_USER || '',
    pass: process.env.EMAIL_PASS || ''
  },
  from: process.env.EMAIL_FROM || 'noreply@energyefficientstore.com',
  replyTo: process.env.EMAIL_REPLY_TO
};

export const emailConfiguration = new EmailConfiguration(emailConfig);

// Custom error class for email-related errors
export class EmailConfigError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'EmailConfigError';
  }
}

----- End of backend\src\config\email.ts -----



----- Start of backend\src\config\logger.ts -----

// backend/src/config/logger.ts

import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import path from 'path';

// Define severity levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Define colors for each severity level
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'white',
};

// Add colors to Winston
winston.addColors(colors);

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.errors({ stack: true }),
  winston.format.metadata(),
  winston.format.printf(({ timestamp, level, message, metadata, stack }) => {
    // Clean metadata by removing sensitive information
    const cleanMetadata = { ...metadata };
    delete cleanMetadata.password;
    delete cleanMetadata.token;
    delete cleanMetadata.authorization;

    return JSON.stringify({
      timestamp,
      level,
      message,
      ...(Object.keys(cleanMetadata).length > 2 && { metadata: cleanMetadata }),
      ...(stack && { stack }),
    });
  })
);

// Define the log directory
const logDir = process.env.LOG_DIR || 'logs';

// Create rotating transport for file logging
const rotatingFileTransport = new DailyRotateFile({
  dirname: path.join(process.cwd(), logDir),
  filename: '%DATE%-app.log',
  datePattern: 'YYYY-MM-DD',
  zippedArchive: true,
  maxSize: '20m',
  maxFiles: '14d',
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
});

// Create console transport with color
const consoleTransport = new winston.transports.Console({
  format: winston.format.combine(
    winston.format.colorize({ all: true }),
    winston.format.simple()
  ),
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
});

// Create error log transport
const errorLogTransport = new DailyRotateFile({
  dirname: path.join(process.cwd(), logDir),
  filename: '%DATE%-error.log',
  datePattern: 'YYYY-MM-DD',
  zippedArchive: true,
  maxSize: '20m',
  maxFiles: '30d',
  level: 'error',
});

// Create HTTP request log transport
const httpLogTransport = new DailyRotateFile({
  dirname: path.join(process.cwd(), logDir),
  filename: '%DATE%-http.log',
  datePattern: 'YYYY-MM-DD',
  zippedArchive: true,
  maxSize: '20m',
  maxFiles: '7d',
  level: 'http',
});

// Create the logger instance
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  levels,
  format: logFormat,
  transports: [
    rotatingFileTransport,
    consoleTransport,
    errorLogTransport,
    httpLogTransport,
  ],
  // Don't exit on uncaught errors
  exitOnError: false,
});

// Create a stream object for Morgan HTTP logging
export const httpLogStream = {
  write: (message: string) => {
    logger.http(message.trim());
  },
};

// Add error event handlers
logger.on('error', (error) => {
  console.error('Logger error:', error);
});

rotatingFileTransport.on('rotate', (oldFilename, newFilename) => {
  logger.info('Log file rotated', { oldFilename, newFilename });
});

// Helper function to clean sensitive data from logs
export const cleanSensitiveData = (data: any): any => {
  if (!data) return data;

  const sensitiveFields = ['password', 'token', 'authorization', 'creditCard'];
  const cleaned = { ...data };

  sensitiveFields.forEach(field => {
    if (field in cleaned) {
      cleaned[field] = '[REDACTED]';
    }
  });

  return cleaned;
};

// Custom logging functions with type safety
export interface LogMetadata {
  userId?: string;
  requestId?: string;
  component?: string;
  [key: string]: any;
}

class Logger {
  error(message: string, metadata?: LogMetadata, error?: Error) {
    logger.error(message, {
      ...cleanSensitiveData(metadata),
      ...(error && { error: error.stack || error.message }),
    });
  }

  warn(message: string, metadata?: LogMetadata) {
    logger.warn(message, cleanSensitiveData(metadata));
  }

  info(message: string, metadata?: LogMetadata) {
    logger.info(message, cleanSensitiveData(metadata));
  }

  http(message: string, metadata?: LogMetadata) {
    logger.http(message, cleanSensitiveData(metadata));
  }

  debug(message: string, metadata?: LogMetadata) {
    logger.debug(message, cleanSensitiveData(metadata));
  }

  // Log audit events separately
  audit(action: string, metadata: LogMetadata) {
    logger.info(`AUDIT: ${action}`, {
      ...cleanSensitiveData(metadata),
      audit: true,
      timestamp: new Date().toISOString(),
    });
  }
}

// Export singleton instance
export const appLogger = new Logger();

// Export winston logger for advanced usage if needed
export const winstonLogger = logger;

// Export types
export type LogLevel = keyof typeof levels;

----- End of backend\src\config\logger.ts -----



----- Start of backend\src\middleware\auth.ts -----

// backend/src/middleware/auth.ts

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { rateLimit } from 'express-rate-limit';
import { pool } from '../config/database';

interface AuthRequest extends Request {
  user?: {
    userId: string;
    email: string;
    role?: string;
  };
}

export const authenticate = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.cookies.token || req.headers.authorization?.split(' ')[1];

    if (!token) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as jwt.JwtPayload;

    // Verify session exists
    const session = await pool.query(
      'SELECT * FROM sessions WHERE token = $1 AND expires_at > NOW()',
      [token]
    );

    if (session.rows.length === 0) {
      return res.status(401).json({ error: 'Session expired' });
    }

    req.user = {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role
    };

    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

export const requireRole = (roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user?.role || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
};

export const rateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: { error: 'Too many requests' },
  standardHeaders: true,
  legacyHeaders: false
});

export const validateSession = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.cookies.token || req.headers.authorization?.split(' ')[1];

    if (!token) {
      return next();
    }

    const session = await pool.query(
      'SELECT * FROM sessions WHERE token = $1',
      [token]
    );

    if (session.rows.length === 0) {
      res.clearCookie('token');
      return res.status(401).json({ error: 'Invalid session' });
    }

    if (new Date(session.rows[0].expires_at) < new Date()) {
      await pool.query('DELETE FROM sessions WHERE token = $1', [token]);
      res.clearCookie('token');
      return res.status(401).json({ error: 'Session expired' });
    }

    next();
  } catch (error) {
    next(error);
  }
};

// Validation middleware
export const validateInput = (schema: any) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const { error } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }
    next();
  };
};

// Error handling middleware
export const errorHandler = (
  error: any,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error(error);

  if (error.name === 'ValidationError') {
    return res.status(400).json({ error: error.message });
  }

  if (error.name === 'UnauthorizedError') {
    return res.status(401).json({ error: 'Invalid token' });
  }

  res.status(500).json({ error: 'Internal server error' });
};

// Activity logging middleware
export const logActivity = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  if (req.user?.userId) {
    const eventData = {
      path: req.path,
      method: req.method,
      query: req.query,
      body: req.method === 'POST' ? req.body : undefined
    };

    try {
      await pool.query(
        `INSERT INTO analytics_data (
          user_id, event_type, event_data
        ) VALUES ($1, $2, $3)`,
        [req.user.userId, 'api_request', eventData]
      );
    } catch (error) {
      console.error('Failed to log activity:', error);
    }
  }
  next();
};

export const validateEmailVerification = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.user) {
    return next();
  }

  const result = await pool.query(
    'SELECT email_verified FROM users WHERE id = $1',
    [req.user.userId]
  );

  if (!result.rows[0]?.email_verified) {
    return res.status(403).json({
      error: 'Email verification required',
      code: 'EMAIL_VERIFICATION_REQUIRED'
    });
  }

  next();
};

----- End of backend\src\middleware\auth.ts -----



----- Start of backend\src\middleware\security.ts -----

// backend/src/middleware/security.ts

import { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { pool } from '../config/database';

// Rate limiting configurations
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  message: { error: 'Too many login attempts. Please try again later.' },
  standardHeaders: true,
  legacyHeaders: false
});

export const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute
  message: { error: 'Too many requests. Please try again later.' }
});

export const auditLimiter = rateLimit({
  windowMs: 24 * 60 * 60 * 1000, // 24 hours
  max: 5, // 5 audits per day
  message: { error: 'Daily audit limit reached.' }
});

export const rateLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 60, // 60 requests per minute
  message: { error: 'Too many requests. Please try again later.' }
});

// IP blocking middleware
export const ipBlocker = async (req: Request, res: Response, next: NextFunction) => {
  const clientIP = req.ip;

  const result = await pool.query(
    'SELECT * FROM blocked_ips WHERE ip = $1 AND blocked_until > NOW()',
    [clientIP]
  );

  if (result.rows.length > 0) {
    return res.status(403).json({
      error: 'Access denied',
      blockedUntil: result.rows[0].blocked_until
    });
  }

  next();
};

// Security headers
export const securityHeaders = [
  helmet(),
  helmet.contentSecurityPolicy({
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", 'cdnjs.cloudflare.com'],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'", process.env.API_URL || 'http://localhost:5000'],
      fontSrc: ["'self'", 'https:', 'data:'],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    }
  }),
  helmet.dnsPrefetchControl({ allow: false }),
  helmet.frameguard({ action: 'deny' }),
  helmet.hsts({
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }),
  helmet.referrerPolicy({ policy: 'same-origin' })
];

// Request sanitization
export const sanitizeRequest = (req: Request, res: Response, next: NextFunction) => {
  if (req.body) {
    Object.keys(req.body).forEach(key => {
      if (typeof req.body[key] === 'string') {
        req.body[key] = req.body[key].trim().replace(/[<>]/g, '');
      }
    });
  }
  next();
};

// Brute force protection
interface FailedAttempt {
  count: number;
  firstAttempt: Date;
  blockedUntil?: Date;
}

const failedAttempts = new Map<string, FailedAttempt>();

export const bruteForceProtection = async (req: Request, res: Response, next: NextFunction) => {
  const clientIP = req.ip;
  const attempt = failedAttempts.get(clientIP) || { count: 0, firstAttempt: new Date() };

  if (attempt.blockedUntil && attempt.blockedUntil > new Date()) {
    return res.status(403).json({
      error: 'Account locked',
      blockedUntil: attempt.blockedUntil
    });
  }

  // Reset if outside window
  if (Date.now() - attempt.firstAttempt.getTime() > 15 * 60 * 1000) {
    failedAttempts.delete(clientIP);
  }

  req.on('end', () => {
    if (res.statusCode === 401) {
      attempt.count++;

      if (attempt.count >= 5) {
        attempt.blockedUntil = new Date(Date.now() + 15 * 60 * 1000);

        // Log to database
        pool.query(
          'INSERT INTO blocked_ips (ip, blocked_until) VALUES ($1, $2)',
          [clientIP, attempt.blockedUntil]
        ).catch(console.error);
      }

      failedAttempts.set(clientIP, attempt);
    }
  });

  next();
};

// CORS configuration
export const corsOptions = {
  origin: process.env.FRONTEND_URL || 'http://localhost:5173',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  maxAge: 600
};

// SQL injection protection
export const sqlInjectionProtection = (req: Request, res: Response, next: NextFunction) => {
  const sqlInjectionPattern = /('|--|;|\/\*|\*\/|xp_|UNION|SELECT|INSERT|UPDATE|DELETE|DROP|TRUNCATE)/i;

  const checkValue = (value: any): boolean => {
    if (typeof value === 'string' && sqlInjectionPattern.test(value)) {
      return true;
    }
    if (typeof value === 'object' && value !== null) {
      return Object.values(value).some(v => checkValue(v));
    }
    return false;
  };

  if (checkValue(req.query) || checkValue(req.body)) {
    return res.status(403).json({ error: 'Invalid input detected' });
  }

  next();
};

----- End of backend\src\middleware\security.ts -----



----- Start of backend\src\middleware\validators.ts -----

// backend/src/middleware/validators.ts

import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';

// User validation schemas
const userSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  fullName: z.string().min(2),
  phone: z.string().optional(),
  address: z.string().optional()
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string()
});

// Energy audit validation schemas
const homeDetailsSchema = z.object({
  yearBuilt: z.number().min(1800).max(new Date().getFullYear()),
  homeSize: z.number().min(100).max(50000),
  numRooms: z.number().min(1).max(100),
  homeType: z.enum(['apartment', 'single-family', 'townhouse', 'duplex', 'other']),
  numFloors: z.number().min(1).max(100),
  basementType: z.enum(['full', 'partial', 'crawlspace', 'slab', 'none', 'other'])
});

const currentConditionsSchema = z.object({
  insulation: z.object({
    attic: z.enum(['poor', 'average', 'good', 'excellent', 'not-sure']),
    walls: z.enum(['poor', 'average', 'good', 'excellent', 'not-sure']),
    basement: z.enum(['poor', 'average', 'good', 'excellent', 'not-sure']),
    floor: z.enum(['poor', 'average', 'good', 'excellent', 'not-sure'])
  }),
  windowType: z.enum(['single', 'double', 'triple', 'not-sure']),
  numWindows: z.number().min(0),
  windowCondition: z.enum(['excellent', 'good', 'fair', 'poor']),
  weatherStripping: z.enum(['door-sweep', 'foam', 'metal', 'none', 'not-sure'])
});

const heatingCoolingSchema = z.object({
  heatingSystem: z.object({
    type: z.enum(['furnace', 'boiler', 'heat-pump', 'electric-baseboard', 'other']),
    fuelType: z.enum(['natural-gas', 'oil', 'electric', 'propane', 'other']),
    age: z.number().min(0).max(100),
    lastService: z.string().datetime()
  }),
  coolingSystem: z.object({
    type: z.enum(['central', 'window-unit', 'portable', 'none']),
    age: z.number().min(0).max(100)
  })
});

const energyUsageSchema = z.object({
  month: z.string().datetime(),
  consumption: z.number().positive(),
  cost: z.number().positive()
});

const userSettingsSchema = z.object({
  emailNotifications: z.boolean(),
  theme: z.enum(['light', 'dark']),
  currency: z.string().length(3),
  unitSystem: z.enum(['imperial', 'metric'])
});

// Validator middleware factory
export const validate = (schema: z.ZodSchema) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          error: 'Validation failed',
          details: error.errors.map(err => ({
            path: err.path.join('.'),
            message: err.message
          }))
        });
      } else {
        next(error);
      }
    }
  };
};

// Export validator middlewares
export const validators = {
  validateUser: validate(userSchema),
  validateLogin: validate(loginSchema),
  validateHomeDetails: validate(homeDetailsSchema),
  validateCurrentConditions: validate(currentConditionsSchema),
  validateHeatingCooling: validate(heatingCoolingSchema),
  validateEnergyUsage: validate(energyUsageSchema),
  validateUserSettings: validate(userSettingsSchema),

  // Combined audit data validation
  validateAuditData: (req: Request, res: Response, next: NextFunction) => {
    const auditSchema = z.object({
      homeDetails: homeDetailsSchema,
      currentConditions: currentConditionsSchema,
      heatingCooling: heatingCoolingSchema
    });

    try {
      auditSchema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          error: 'Audit data validation failed',
          details: error.errors
        });
      } else {
        next(error);
      }
    }
  }
};

----- End of backend\src\middleware\validators.ts -----



----- Start of backend\src\routes\analytics.ts -----

// backend/src/routes/analytics.ts

import express from 'express';
import { authenticate, requireRole } from '../middleware/auth';
import { rateLimiter } from '../middleware/security';
import { AnalyticsService } from '../services/analyticsService';
import { pool } from '../config/database';

const router = express.Router();
const analyticsService = new AnalyticsService(pool);

/**
 * @route GET /api/analytics/dashboard
 * @desc Get dashboard analytics data
 * @access Private (Admin)
 */
router.get('/dashboard',
  authenticate,
  requireRole(['admin']),
  rateLimiter,
  async (req, res) => {
    try {
      const timeframe = req.query.timeframe as string || 'month';
      const metrics = await analyticsService.getPlatformMetrics(timeframe);
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/analytics/user/:userId
 * @desc Get user-specific analytics
 * @access Private (Admin or User's own data)
 */
router.get('/user/:userId',
  authenticate,
  async (req, res) => {
    try {
      // Check if user is requesting their own data or is an admin
      if (req.user!.userId !== req.params.userId && req.user!.role !== 'admin') {
        return res.status(403).json({ error: 'Unauthorized access' });
      }

      const timeframe = req.query.timeframe as string || 'month';
      const metrics = await analyticsService.getUserMetrics(req.params.userId, timeframe);
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route POST /api/analytics/track
 * @desc Track user action
 * @access Private
 */
router.post('/track',
  authenticate,
  rateLimiter,
  async (req, res) => {
    try {
      const { action, metadata } = req.body;
      await analyticsService.trackUserAction(req.user!.userId, action, metadata);
      res.status(200).end();
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/analytics/reports
 * @desc Get analytics reports
 * @access Private (Admin)
 */
router.get('/reports',
  authenticate,
  requireRole(['admin']),
  async (req, res) => {
    try {
      const timeframe = req.query.timeframe as string || 'month';
      const reportId = await analyticsService.generateAnalyticsReport(timeframe);
      res.json({ reportId });
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/analytics/reports/:reportId
 * @desc Get specific analytics report
 * @access Private (Admin)
 */
router.get('/reports/:reportId',
  authenticate,
  requireRole(['admin']),
  async (req, res) => {
    try {
      const report = await analyticsService.getAnalyticsReport(req.params.reportId);
      res.json(report);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/analytics/energy-savings
 * @desc Get platform-wide energy savings metrics
 * @access Public
 */
router.get('/energy-savings',
  rateLimiter,
  async (req, res) => {
    try {
      const timeframe = req.query.timeframe as string || 'all';
      const result = await pool.query(
        `SELECT
          COUNT(DISTINCT user_id) as total_users,
          SUM(energy_savings) as total_savings,
          AVG(energy_savings) as average_savings
         FROM user_progress
         WHERE ${timeframe === 'all' ? '1=1' : `created_at >= NOW() - INTERVAL '1 ${timeframe}'`}`
      );

      res.json({
        totalUsers: result.rows[0].total_users,
        totalSavings: result.rows[0].total_savings,
        averageSavings: result.rows[0].average_savings
      });
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/analytics/product-engagement/:productId
 * @desc Get product engagement metrics
 * @access Private (Admin)
 */
router.get('/product-engagement/:productId',
  authenticate,
  requireRole(['admin']),
  async (req, res) => {
    try {
      const result = await pool.query(
        `SELECT
          COUNT(*) as view_count,
          COUNT(DISTINCT user_id) as unique_viewers,
          COUNT(CASE WHEN action_type = 'purchase' THEN 1 END) as purchase_count
         FROM user_actions
         WHERE metadata->>'productId' = $1
         AND created_at >= NOW() - INTERVAL '30 days'`,
        [req.params.productId]
      );

      res.json(result.rows[0]);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

export default router;

----- End of backend\src\routes\analytics.ts -----



----- Start of backend\src\routes\auth.ts -----

// src/routes/auth.ts
import express from 'express';
import { UserAuthService } from '../services/userAuthService';
import { pool } from '../config/database';
import { authenticate, rateLimiter, csrfProtection } from '../middleware/auth';

const router = express.Router();
const authService = new UserAuthService(pool);

// Register new user
router.post('/register', rateLimiter(60 * 1000, 5), async (req, res) => {
  try {
    const { email, password, fullName, phone, address } = req.body;

    if (!email || !password || !fullName) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await authService.registerUser(email, password, fullName, phone, address);
    res.status(201).json(result);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});

// Login user
router.post('/login', rateLimiter(60 * 1000, 5), async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Missing email or password' });
    }

    const result = await authService.loginUser(email, password);

    // Set HTTP-only cookie with JWT
    res.cookie('token', result.token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    });

    res.json(result);
  } catch (error) {
    if (error instanceof Error) {
      res.status(401).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});

// Logout user
router.post('/logout', (req, res) => {
  res.clearCookie('token');
  res.json({ message: 'Logged out successfully' });
});

// Get current user profile
router.get('/profile', authenticate, async (req, res) => {
  try {
    const userId = req.user?.userId;
    const result = await pool.query(
      'SELECT id, email, full_name, phone, address, role FROM users WHERE id = $1',
      [userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user profile
router.put('/profile', authenticate, csrfProtection, async (req, res) => {
  try {
    const userId = req.user?.userId;
    const { fullName, phone, address } = req.body;

    const updatedUser = await authService.updateUserProfile(userId!, {
      fullName,
      phone,
      address
    });

    res.json(updatedUser);
  } catch (error) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});

// Request password reset
router.post('/password-reset-request', rateLimiter(60 * 1000, 3), async (req, res) => {
  try {
    const { email } = req.body;

    // Check if user exists
    const result = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
    if (result.rows.length === 0) {
      // Return success even if email doesn't exist to prevent email enumeration
      return res.json({ message: 'If an account exists, a reset link will be sent' });
    }

    // Generate reset token
    const resetToken = Math.random().toString(36).substring(2, 15);
    const resetExpires = new Date(Date.now() + 3600000); // 1 hour

    await pool.query(
      'UPDATE users SET reset_token = $1, reset_expires = $2 WHERE email = $3',
      [resetToken, resetExpires, email]
    );

    // TODO: Send email with reset link
    // For now, just return the token in development
    if (process.env.NODE_ENV === 'development') {
      res.json({ resetToken });
    } else {
      res.json({ message: 'If an account exists, a reset link will be sent' });
    }
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Reset password
router.post('/password-reset', rateLimiter(60 * 1000, 3), async (req, res) => {
  try {
    const { token, newPassword } = req.body;

    const result = await pool.query(
      'SELECT id FROM users WHERE reset_token = $1 AND reset_expires > NOW()',
      [token]
    );

    if (result.rows.length === 0) {
      return res.status(400).json({ error: 'Invalid or expired reset token' });
    }

    const userId = result.rows[0].id;
    const passwordHash = await bcrypt.hash(newPassword, 12);

    await pool.query(
      'UPDATE users SET password_hash = $1, reset_token = NULL, reset_expires = NULL WHERE id = $2',
      [passwordHash, userId]
    );

    res.json({ message: 'Password reset successful' });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;

----- End of backend\src\routes\auth.ts -----



----- Start of backend\src\routes\emailVerification.ts -----

// src/routes/emailVerification.ts
import express from 'express';
import { v4 as uuidv4 } from 'uuid';
import { pool } from '../config/database';
import { authenticate } from '../middleware/auth';

const router = express.Router();

// Send verification email
router.post('/send-verification', authenticate, async (req, res) => {
  try {
    const userId = req.user?.userId;
    const verifyToken = uuidv4();
    const verifyExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    await pool.query(
      `UPDATE users
       SET email_verify_token = $1,
           email_verify_expires = $2
       WHERE id = $3`,
      [verifyToken, verifyExpires, userId]
    );

    // TODO: Integrate with email service
    const verificationLink = `${process.env.APP_URL}/verify-email/${verifyToken}`;

    if (process.env.NODE_ENV === 'development') {
      res.json({ verificationLink });
    } else {
      res.json({ message: 'Verification email sent' });
    }
  } catch (error) {
    res.status(500).json({ error: 'Failed to send verification email' });
  }
});

// Verify email
router.get('/verify/:token', async (req, res) => {
  try {
    const { token } = req.params;

    const result = await pool.query(
      `UPDATE users
       SET email_verified = TRUE,
           email_verify_token = NULL,
           email_verify_expires = NULL
       WHERE email_verify_token = $1
       AND email_verify_expires > CURRENT_TIMESTAMP
       RETURNING id`,
      [token]
    );

    if (result.rowCount === 0) {
      return res.status(400).json({ error: 'Invalid or expired verification token' });
    }

    res.json({ message: 'Email verified successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Verification failed' });
  }
});

// Check verification status
router.get('/status', authenticate, async (req, res) => {
  try {
    const userId = req.user?.userId;

    const result = await pool.query(
      'SELECT email_verified FROM users WHERE id = $1',
      [userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ verified: result.rows[0].email_verified });
  } catch (error) {
    res.status(500).json({ error: 'Failed to check verification status' });
  }
});

export default router;

----- End of backend\src\routes\emailVerification.ts -----



----- Start of backend\src\routes\energyAudit.ts -----

// backend/src/routes/energyAudit.ts

import express from 'express';
import { authenticate, validateEmailVerification, auditLimiter } from '../middleware/auth';
import { validators } from '../middleware/validators';
import { EnergyAuditService } from '../services/EnergyAuditService';
import { pool } from '../config/database';

const router = express.Router();
const auditService = new EnergyAuditService(pool);

// Submit new audit
router.post('/',
  authenticate,
  validateEmailVerification,
  auditLimiter,
  validators.validateAuditData,
  async (req, res) => {
    try {
      const auditId = await auditService.submitAudit({
        ...req.body,
        basicInfo: {
          ...req.body.basicInfo,
          userId: req.user!.userId
        }
      });
      res.status(201).json({ auditId });
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
});

// Get audit by ID
router.get('/:id', authenticate, async (req, res) => {
  try {
    const audit = await pool.query(
      'SELECT * FROM energy_audits WHERE id = $1 AND user_id = $2',
      [req.params.id, req.user!.userId]
    );

    if (audit.rows.length === 0) {
      return res.status(404).json({ error: 'Audit not found' });
    }

    res.json(audit.rows[0]);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

// Get user's audit history
router.get('/', authenticate, async (req, res) => {
  try {
    const audits = await auditService.getAuditHistory(req.user!.userId);
    res.json(audits);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

// Update audit
router.put('/:id',
  authenticate,
  validators.validateAuditData,
  async (req, res) => {
    try {
      const { id } = req.params;
      const audit = await pool.query(
        'SELECT * FROM energy_audits WHERE id = $1 AND user_id = $2',
        [id, req.user!.userId]
      );

      if (audit.rows.length === 0) {
        return res.status(404).json({ error: 'Audit not found' });
      }

      if (audit.rows[0].status === 'completed') {
        return res.status(400).json({ error: 'Cannot update completed audit' });
      }

      const client = await pool.connect();
      try {
        await client.query('BEGIN');

        // Log changes
        const oldData = audit.rows[0];
        const changes = Object.keys(req.body).filter(key =>
          JSON.stringify(oldData[key]) !== JSON.stringify(req.body[key])
        );

        for (const field of changes) {
          await client.query(
            `INSERT INTO audit_history (
              audit_id, field_name, old_value, new_value
            ) VALUES ($1, $2, $3, $4)`,
            [id, field, oldData[field], req.body[field]]
          );
        }

        // Update audit
        await client.query(
          `UPDATE energy_audits SET
            home_details = $1,
            current_conditions = $2,
            heating_cooling = $3,
            energy_consumption = $4,
            lighting_details = $5,
            renewable_potential = $6,
            financial_details = $7,
            updated_at = CURRENT_TIMESTAMP
           WHERE id = $8`,
          [
            req.body.homeDetails,
            req.body.currentConditions,
            req.body.heatingCooling,
            req.body.energyConsumption,
            req.body.lightingDetails,
            req.body.renewablePotential,
            req.body.financialDetails,
            id
          ]
        );

        await client.query('COMMIT');
        res.json({ message: 'Audit updated successfully' });
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
});

// Complete audit
router.post('/:id/complete', authenticate, async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(
      `UPDATE energy_audits
       SET status = 'completed',
           completed_at = CURRENT_TIMESTAMP,
           recommendations = $1
       WHERE id = $2 AND user_id = $3
       RETURNING *`,
      [req.body.recommendations, id, req.user!.userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Audit not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

export default router;

----- End of backend\src\routes\energyAudit.ts -----



----- Start of backend\src\routes\products.ts -----

// backend/src/routes/products.ts

import express from 'express';
import { authenticate } from '../middleware/auth';
import { apiLimiter } from '../middleware/security';
import { ProductDataService } from '../services/productDataService';
import { pool } from '../config/database';

const router = express.Router();
const productService = new ProductDataService();

router.get('/', apiLimiter, async (req, res) => {
  try {
    const filters = {
      mainCategory: req.query.category as string,
      subCategory: req.query.subcategory as string,
      search: req.query.search as string,
      efficiency: req.query.efficiency as string
    };

    const products = await productService.getProducts(filters);
    res.json(products);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

router.get('/categories', async (req, res) => {
  try {
    const categories = await productService.getCategories();
    res.json(categories);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

router.get('/:id', async (req, res) => {
  try {
    const product = await productService.getProduct(req.params.id);
    if (!product) {
      return res.status(404).json({ error: 'Product not found' });
    }
    res.json(product);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

router.post('/:id/view', authenticate, async (req, res) => {
  try {
    await pool.query(
      `INSERT INTO analytics_data (
        user_id, event_type, event_data
      ) VALUES ($1, $2, $3)`,
      [
        req.user!.userId,
        'product_view',
        { productId: req.params.id, timestamp: new Date() }
      ]
    );
    res.status(200).end();
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

router.get('/:id/similar', async (req, res) => {
  try {
    const product = await productService.getProduct(req.params.id);
    if (!product) {
      return res.status(404).json({ error: 'Product not found' });
    }

    const similarProducts = await pool.query(
      `SELECT * FROM products
       WHERE main_category = $1
       AND sub_category = $2
       AND id != $3
       LIMIT 4`,
      [product.mainCategory, product.subCategory, req.params.id]
    );

    res.json(similarProducts.rows);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

router.get('/:id/recommendations', authenticate, async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT r.* FROM recommendations r
       JOIN energy_audits a ON r.audit_id = a.id
       WHERE r.product_id = $1 AND a.user_id = $2
       ORDER BY r.created_at DESC`,
      [req.params.id, req.user!.userId]
    );
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

router.post('/sync', async (req, res) => {
  try {
    const success = await productService.loadProductsFromCSV('/data/products.csv');
    if (!success) {
      return res.status(500).json({ error: 'Failed to sync products' });
    }
    res.json({ message: 'Products synced successfully' });
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

router.get('/:id/energy-savings', async (req, res) => {
  try {
    const product = await productService.getProduct(req.params.id);
    if (!product) {
      return res.status(404).json({ error: 'Product not found' });
    }

    const efficiency = parseFloat(product.efficiency.replace(/[^0-9.]/g, '')) / 100;
    const averageSavings = {
      annual: Math.round(1000 * efficiency), // Placeholder calculation
      tenYear: Math.round(1000 * efficiency * 10)
    };

    res.json(averageSavings);
  } catch (error) {
    res.status(500).json({ error: (error as Error).message });
  }
});

export default router;

----- End of backend\src\routes\products.ts -----



----- Start of backend\src\routes\recommendations.ts -----

// backend/src/routes/recommendations.ts

import express from 'express';
import { authenticate, validateEmailVerification } from '../middleware/auth';
import { rateLimiter } from '../middleware/security';
import { RecommendationService } from '../services/recommendationService';
import { pool } from '../config/database';
import { EnergyAuditService } from '../services/EnergyAuditService';

const router = express.Router();
const recommendationService = new RecommendationService(pool);
const auditService = new EnergyAuditService(pool);

/**
 * @route GET /api/recommendations
 * @desc Get personalized recommendations for the authenticated user
 * @access Private
 */
router.get('/',
  authenticate,
  validateEmailVerification,
  rateLimiter,
  async (req, res) => {
    try {
      const recommendations = await recommendationService.getUserRecommendations(req.user!.userId);
      res.json(recommendations);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route POST /api/recommendations/generate
 * @desc Generate new recommendations based on audit data
 * @access Private
 */
router.post('/generate',
  authenticate,
  validateEmailVerification,
  async (req, res) => {
    try {
      const { auditId } = req.body;

      // Verify audit belongs to user
      const audit = await auditService.getAuditById(auditId);
      if (!audit || audit.userId !== req.user!.userId) {
        return res.status(403).json({ error: 'Unauthorized access to audit' });
      }

      const recommendations = await recommendationService.generateRecommendations(
        req.user!.userId,
        audit
      );

      await recommendationService.storeRecommendations(recommendations);

      res.json(recommendations);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/recommendations/products
 * @desc Get product recommendations based on user profile and history
 * @access Private
 */
router.get('/products',
  authenticate,
  rateLimiter,
  async (req, res) => {
    try {
      const category = req.query.category as string;
      const limit = parseInt(req.query.limit as string) || 10;

      const recommendations = await recommendationService.getProductRecommendations(
        req.user!.userId,
        { category, limit }
      );

      res.json(recommendations);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/recommendations/savings
 * @desc Get energy savings recommendations
 * @access Private
 */
router.get('/savings',
  authenticate,
  rateLimiter,
  async (req, res) => {
    try {
      const savings = await recommendationService.getEnergySavingsRecommendations(
        req.user!.userId
      );
      res.json(savings);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route POST /api/recommendations/:id/feedback
 * @desc Submit feedback on a recommendation
 * @access Private
 */
router.post('/:id/feedback',
  authenticate,
  async (req, res) => {
    try {
      const { helpful, feedback } = req.body;

      await pool.query(
        `INSERT INTO recommendation_feedback (
          recommendation_id, user_id, helpful, feedback
        ) VALUES ($1, $2, $3, $4)`,
        [req.params.id, req.user!.userId, helpful, feedback]
      );

      // Update recommendation effectiveness score
      await recommendationService.updateRecommendationScore(req.params.id, helpful);

      res.status(200).end();
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route POST /api/recommendations/:id/implement
 * @desc Mark a recommendation as implemented
 * @access Private
 */
router.post('/:id/implement',
  authenticate,
  async (req, res) => {
    try {
      const { implementationDate, notes } = req.body;

      const result = await pool.query(
        `UPDATE recommendations
         SET implemented = true,
             implementation_date = $1,
             implementation_notes = $2
         WHERE id = $3 AND user_id = $4
         RETURNING *`,
        [implementationDate, notes, req.params.id, req.user!.userId]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Recommendation not found' });
      }

      // Update user progress
      await pool.query(
        `UPDATE user_progress
         SET implementations_count = implementations_count + 1,
             total_points = total_points + 100
         WHERE user_id = $1`,
        [req.user!.userId]
      );

      res.json(result.rows[0]);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

/**
 * @route GET /api/recommendations/progress
 * @desc Get implementation progress of recommendations
 * @access Private
 */
router.get('/progress',
  authenticate,
  async (req, res) => {
    try {
      const result = await pool.query(
        `SELECT
          COUNT(*) as total_recommendations,
          COUNT(CASE WHEN implemented THEN 1 END) as implemented_count,
          SUM(estimated_savings) as potential_savings,
          SUM(CASE WHEN implemented THEN estimated_savings ELSE 0 END) as achieved_savings
         FROM recommendations
         WHERE user_id = $1`,
        [req.user!.userId]
      );

      res.json(result.rows[0]);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
);

export default router;

----- End of backend\src\routes\recommendations.ts -----



----- Start of backend\src\routes\userSettings.ts -----

// src/routes/userSettings.ts

import express from 'express';
import { authenticate, requireRole, validateRequest } from '../middleware/auth';
import { AuthService } from '../services/auth/AuthService';
import { pool } from '../config/database';

const router = express.Router();
const authService = new AuthService(pool);

// Get user settings
router.get('/', authenticate, async (req, res) => {
  try {
    const settings = await authService.getUserSettings(req.user!.userId);
    res.json(settings);
  } catch (error) {
    res.status(400).json({ error: (error as Error).message });
  }
});

// Update user settings
router.put('/', authenticate, async (req, res) => {
  try {
    const { fullName, phone, address, emailNotifications, theme } = req.body;

    // Update user profile
    const settings = await authService.updateUserSettings(req.user!.userId, {
      fullName,
      phone,
      address
    });

    // Update preferences in user_settings table
    await pool.query(
      `INSERT INTO user_settings (user_id, email_notifications, theme)
       VALUES ($1, $2, $3)
       ON CONFLICT (user_id)
       DO UPDATE SET
         email_notifications = $2,
         theme = $3,
         updated_at = CURRENT_TIMESTAMP`,
      [req.user!.userId, emailNotifications, theme]
    );

    res.json(settings);
  } catch (error) {
    res.status(400).json({ error: (error as Error).message });
  }
});

// Delete account
router.delete('/', authenticate, async (req, res) => {
  try {
    const { password } = req.body;

    if (!password) {
      return res.status(400).json({ error: 'Password required for account deletion' });
    }

    // Verify password before deletion
    await authService.verifyPassword(req.user!.userId, password);

    // Delete user (cascades to settings due to foreign key)
    await pool.query('DELETE FROM users WHERE id = $1', [req.user!.userId]);

    res.json({ message: 'Account deleted successfully' });
  } catch (error) {
    res.status(400).json({ error: (error as Error).message });
  }
});

// Export data (GDPR compliance)
router.get('/export', authenticate, async (req, res) => {
  try {
    const userData = await pool.query(
      `SELECT u.*, s.email_notifications, s.theme, s.notification_preferences
       FROM users u
       LEFT JOIN user_settings s ON u.id = s.user_id
       WHERE u.id = $1`,
      [req.user!.userId]
    );

    // Get user's audit history
    const auditHistory = await pool.query(
      'SELECT * FROM audit_history WHERE user_id = $1',
      [req.user!.userId]
    );

    res.json({
      userData: userData.rows[0],
      auditHistory: auditHistory.rows
    });
  } catch (error) {
    res.status(400).json({ error: (error as Error).message });
  }
});

export default router;

----- End of backend\src\routes\userSettings.ts -----



----- Start of backend\src\services\EnergyAuditService.ts -----

// src/services/EnergyAuditService.ts

import { Pool } from 'pg';
import {
  EnergyAuditData,
  HomeDetails,
  CurrentConditions,
  HeatingCooling,
  validateBasicInfo,
  validateHomeDetails
} from '../types/energyAudit';

export interface AuditRecommendation {
  category: string;
  priority: 'high' | 'medium' | 'low';
  title: string;
  description: string;
  estimatedSavings: number;
  estimatedCost: number;
  paybackPeriod: number;
  products?: string[];
}

export class EnergyAuditService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  private calculateInsulationScore(conditions: CurrentConditions): number {
    const scores = {
      poor: 0,
      average: 1,
      good: 2,
      excellent: 3,
      'not-sure': 1
    };

    const {attic, walls, basement, floor} = conditions.insulation;
    return (
      scores[attic] +
      scores[walls] +
      scores[basement] +
      scores[floor]
    ) / 4;
  }

  private calculateWindowScore(conditions: CurrentConditions): number {
    const windowTypeScores = {
      single: 0,
      double: 2,
      triple: 3,
      'not-sure': 1
    };

    const conditionScores = {
      poor: 0,
      fair: 1,
      good: 2,
      excellent: 3
    };

    return (
      windowTypeScores[conditions.windowType] +
      conditionScores[conditions.windowCondition]
    ) / 2;
  }

  private calculateHVACScore(hvac: HeatingCooling): number {
    let score = 3;

    // Age deductions
    if (hvac.heatingSystem.age > 15) score -= 2;
    else if (hvac.heatingSystem.age > 10) score -= 1;

    // Service history deductions
    const lastService = new Date(hvac.heatingSystem.lastService);
    const monthsSinceService = (Date.now() - lastService.getTime()) / (1000 * 60 * 60 * 24 * 30);

    if (monthsSinceService > 12) score -= 1;
    if (monthsSinceService > 24) score -= 1;

    return Math.max(0, score);
  }

  async submitAudit(auditData: EnergyAuditData): Promise<string> {
    // Validate input data
    const basicInfoErrors = validateBasicInfo(auditData.basicInfo);
    const homeDetailsErrors = validateHomeDetails(auditData.homeDetails);

    if (basicInfoErrors.length > 0 || homeDetailsErrors.length > 0) {
      throw new Error('Invalid audit data: ' +
        [...basicInfoErrors, ...homeDetailsErrors].join(', '));
    }

    // Store audit data
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      const result = await client.query(
        `INSERT INTO energy_audits (
          user_id, basic_info, home_details,
          current_conditions, heating_cooling,
          energy_consumption, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)
        RETURNING id`,
        [
          auditData.basicInfo.userId,
          auditData.basicInfo,
          auditData.homeDetails,
          auditData.currentConditions,
          auditData.heatingCooling,
          auditData.energyConsumption
        ]
      );

      await client.query('COMMIT');
      return result.rows[0].id;

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async generateRecommendations(auditId: string): Promise<AuditRecommendation[]> {
    // Fetch audit data
    const result = await this.pool.query(
      'SELECT * FROM energy_audits WHERE id = $1',
      [auditId]
    );

    if (result.rows.length === 0) {
      throw new Error('Audit not found');
    }

    const auditData: EnergyAuditData = result.rows[0];

    // Calculate component scores
    const insulation = this.calculateInsulationScore(auditData.currentConditions);
    const windows = this.calculateWindowScore(auditData.currentConditions);
    const hvac = this.calculateHVACScore(auditData.heatingCooling);

    const recommendations: AuditRecommendation[] = [];

    // Generate recommendations based on scores
    if (insulation < 2) {
      recommendations.push({
        category: 'Insulation',
        priority: 'high',
        title: 'Improve Home Insulation',
        description: 'Add or upgrade insulation in walls and attic',
        estimatedSavings: 500,
        estimatedCost: 2000,
        paybackPeriod: 4,
        products: ['INS-001', 'INS-002']
      });
    }

    if (windows < 1.5) {
      recommendations.push({
        category: 'Windows',
        priority: 'medium',
        title: 'Upgrade Windows',
        description: 'Replace single-pane windows with double-pane',
        estimatedSavings: 300,
        estimatedCost: 5000,
        paybackPeriod: 16.7,
        products: ['WIN-001', 'WIN-002']
      });
    }

    if (hvac < 2) {
      recommendations.push({
        category: 'HVAC',
        priority: 'high',
        title: 'HVAC Maintenance/Upgrade',
        description: 'Schedule HVAC maintenance or consider upgrade',
        estimatedSavings: 400,
        estimatedCost: 1000,
        paybackPeriod: 2.5,
        products: ['HVAC-001']
      });
    }

    return recommendations;
  }

  async getAuditHistory(userId: string): Promise<EnergyAuditData[]> {
    const result = await this.pool.query(
      'SELECT * FROM energy_audits WHERE user_id = $1 ORDER BY created_at DESC',
      [userId]
    );
    return result.rows;
  }
}

// Error handling
export class AuditError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuditError';
  }
}

----- End of backend\src\services\EnergyAuditService.ts -----



----- Start of backend\src\services\analyticsService.ts -----

// backend/src/services/analyticsService.ts

import { Pool } from 'pg';

interface UserMetrics {
  totalAudits: number;
  completedAudits: number;
  productViews: number;
  recommendationsViewed: number;
  recommendationsActioned: number;
  estimatedSavings: number;
  actualSavings: number;
}

interface PlatformMetrics {
  activeUsers: number;
  newUsers: number;
  totalAudits: number;
  productEngagement: Record<string, number>;
  averageSavings: number;
  topProducts: Array<{id: string, views: number}>;
}

export class AnalyticsService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  async trackUserAction(userId: string, action: string, metadata: Record<string, any>): Promise<void> {
    await this.pool.query(
      `INSERT INTO user_actions (user_id, action_type, metadata, created_at)
       VALUES ($1, $2, $3, CURRENT_TIMESTAMP)`,
      [userId, action, metadata]
    );
  }

  async getUserMetrics(userId: string, timeframe: string): Promise<UserMetrics> {
    const timeframeClause = this.getTimeframeClause(timeframe);

    const [auditStats, productStats, savingsStats] = await Promise.all([
      this.getAuditStats(userId, timeframeClause),
      this.getProductEngagementStats(userId, timeframeClause),
      this.getSavingsStats(userId, timeframeClause)
    ]);

    return {
      ...auditStats,
      ...productStats,
      ...savingsStats
    };
  }

  async getPlatformMetrics(timeframe: string): Promise<PlatformMetrics> {
    const timeframeClause = this.getTimeframeClause(timeframe);

    const [userStats, auditStats, productStats, savingsStats] = await Promise.all([
      this.getUserStats(timeframeClause),
      this.getAggregateAuditStats(timeframeClause),
      this.getAggregateProductStats(timeframeClause),
      this.getAggregateSavingsStats(timeframeClause)
    ]);

    return {
      ...userStats,
      ...auditStats,
      ...productStats,
      ...savingsStats
    };
  }

  private async getAuditStats(userId: string, timeframeClause: string) {
    const result = await this.pool.query(
      `SELECT
        COUNT(*) as total_audits,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_audits
       FROM energy_audits
       WHERE user_id = $1 ${timeframeClause}`,
      [userId]
    );

    return {
      totalAudits: result.rows[0].total_audits,
      completedAudits: result.rows[0].completed_audits
    };
  }

  private async getProductEngagementStats(userId: string, timeframeClause: string) {
    const result = await this.pool.query(
      `SELECT
        COUNT(DISTINCT CASE WHEN action_type = 'product_view' THEN metadata->>'productId' END) as product_views,
        COUNT(DISTINCT CASE WHEN action_type = 'recommendation_view' THEN id END) as recommendations_viewed,
        COUNT(DISTINCT CASE WHEN action_type = 'recommendation_action' THEN id END) as recommendations_actioned
       FROM user_actions
       WHERE user_id = $1 ${timeframeClause}`,
      [userId]
    );

    return {
      productViews: result.rows[0].product_views,
      recommendationsViewed: result.rows[0].recommendations_viewed,
      recommendationsActioned: result.rows[0].recommendations_actioned
    };
  }

  private async getSavingsStats(userId: string, timeframeClause: string) {
    const result = await this.pool.query(
      `SELECT
        COALESCE(SUM(estimated_savings), 0) as estimated_savings,
        COALESCE(SUM(actual_savings), 0) as actual_savings
       FROM user_savings
       WHERE user_id = $1 ${timeframeClause}`,
      [userId]
    );

    return {
      estimatedSavings: result.rows[0].estimated_savings,
      actualSavings: result.rows[0].actual_savings
    };
  }

  private async getUserStats(timeframeClause: string) {
    const result = await this.pool.query(
      `SELECT
        COUNT(DISTINCT user_id) as active_users,
        COUNT(DISTINCT CASE
          WHEN created_at ${timeframeClause} THEN user_id
        END) as new_users
       FROM users`
    );

    return {
      activeUsers: result.rows[0].active_users,
      newUsers: result.rows[0].new_users
    };
  }

  private async getAggregateAuditStats(timeframeClause: string) {
    const result = await this.pool.query(
      `SELECT COUNT(*) as total_audits
       FROM energy_audits
       WHERE created_at ${timeframeClause}`
    );

    return {
      totalAudits: result.rows[0].total_audits
    };
  }

  private async getAggregateProductStats(timeframeClause: string) {
    const result = await this.pool.query(
      `SELECT
        metadata->>'productId' as product_id,
        COUNT(*) as view_count
       FROM user_actions
       WHERE action_type = 'product_view'
       AND created_at ${timeframeClause}
       GROUP BY metadata->>'productId'
       ORDER BY view_count DESC
       LIMIT 10`
    );

    return {
      productEngagement: result.rows.reduce((acc, row) => {
        acc[row.product_id] = row.view_count;
        return acc;
      }, {}),
      topProducts: result.rows.map(row => ({
        id: row.product_id,
        views: row.view_count
      }))
    };
  }

  private async getAggregateSavingsStats(timeframeClause: string) {
    const result = await this.pool.query(
      `SELECT AVG(actual_savings) as average_savings
       FROM user_savings
       WHERE created_at ${timeframeClause}`
    );

    return {
      averageSavings: result.rows[0].average_savings || 0
    };
  }

  private getTimeframeClause(timeframe: string): string {
    switch (timeframe) {
      case 'day':
        return '>= CURRENT_DATE';
      case 'week':
        return '>= CURRENT_DATE - INTERVAL \'7 days\'';
      case 'month':
        return '>= CURRENT_DATE - INTERVAL \'30 days\'';
      case 'year':
        return '>= CURRENT_DATE - INTERVAL \'1 year\'';
      default:
        return '';
    }
  }

  async generateAnalyticsReport(timeframe: string = 'month'): Promise<string> {
    const metrics = await this.getPlatformMetrics(timeframe);

    const reportId = crypto.randomUUID();
    await this.pool.query(
      `INSERT INTO analytics_reports (
        id, timeframe, metrics, created_at
      ) VALUES ($1, $2, $3, CURRENT_TIMESTAMP)`,
      [reportId, timeframe, metrics]
    );

    return reportId;
  }

  async getAnalyticsReport(reportId: string) {
    const result = await this.pool.query(
      'SELECT * FROM analytics_reports WHERE id = $1',
      [reportId]
    );

    if (result.rows.length === 0) {
      throw new Error('Report not found');
    }

    return result.rows[0];
  }
}

----- End of backend\src\services\analyticsService.ts -----



----- Start of backend\src\services\emailService.ts -----

// src/services/emailService.ts

import nodemailer from 'nodemailer';
import { readFileSync } from 'fs';
import handlebars from 'handlebars';
import path from 'path';

export interface EmailConfig {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
  from: string;
}

export interface EmailTemplate {
  subject: string;
  text: string;
  html: string;
}

export interface EmailOptions {
  to: string;
  template: string;
  data: Record<string, any>;
}

export class EmailService {
  private transporter: nodemailer.Transporter;
  private templates: Map<string, EmailTemplate>;
  private readonly templateDir: string;

  constructor(config: EmailConfig) {
    this.transporter = nodemailer.createTransport({
      host: config.host,
      port: config.port,
      secure: config.secure,
      auth: config.auth
    });

    this.templates = new Map();
    this.templateDir = path.join(__dirname, '../templates/email');
    this.loadTemplates();
  }

  private loadTemplates(): void {
    // Define available templates and their files
    const templateList = {
      'verification': 'email-verification',
      'password-reset': 'password-reset',
      'welcome': 'welcome-email',
      'audit-complete': 'audit-complete'
    };

    for (const [key, fileName] of Object.entries(templateList)) {
      try {
        // Load template files
        const htmlTemplate = readFileSync(
          path.join(this.templateDir, `${fileName}.html`),
          'utf-8'
        );
        const textTemplate = readFileSync(
          path.join(this.templateDir, `${fileName}.txt`),
          'utf-8'
        );
        const configFile = require(path.join(this.templateDir, `${fileName}.json`));

        // Compile templates
        const compiledHtml = handlebars.compile(htmlTemplate);
        const compiledText = handlebars.compile(textTemplate);

        this.templates.set(key, {
          subject: configFile.subject,
          html: compiledHtml,
          text: compiledText
        });
      } catch (error) {
        console.error(`Failed to load template ${key}:`, error);
        throw new Error(`Email template ${key} could not be loaded`);
      }
    }
  }

  public async sendVerificationEmail(email: string, token: string, name: string): Promise<void> {
    const template = this.templates.get('verification');
    if (!template) {
      throw new Error('Verification email template not found');
    }

    const data = {
      name,
      verificationLink: `${process.env.APP_URL}/verify-email/${token}`,
      expiryHours: 24
    };

    await this.sendEmail({
      to: email,
      template: 'verification',
      data
    });
  }

  public async sendPasswordResetEmail(email: string, token: string): Promise<void> {
    const template = this.templates.get('password-reset');
    if (!template) {
      throw new Error('Password reset email template not found');
    }

    const data = {
      resetLink: `${process.env.APP_URL}/reset-password/${token}`,
      expiryHours: 1
    };

    await this.sendEmail({
      to: email,
      template: 'password-reset',
      data
    });
  }

  public async sendWelcomeEmail(email: string, name: string): Promise<void> {
    const template = this.templates.get('welcome');
    if (!template) {
      throw new Error('Welcome email template not found');
    }

    const data = {
      name,
      loginUrl: `${process.env.APP_URL}/login`,
      supportEmail: process.env.SUPPORT_EMAIL
    };

    await this.sendEmail({
      to: email,
      template: 'welcome',
      data
    });
  }

  public async sendAuditCompleteEmail(email: string, auditId: string, recommendations: any[]): Promise<void> {
    const template = this.templates.get('audit-complete');
    if (!template) {
      throw new Error('Audit complete email template not found');
    }

    const data = {
      auditUrl: `${process.env.APP_URL}/audits/${auditId}`,
      recommendations,
      supportEmail: process.env.SUPPORT_EMAIL
    };

    await this.sendEmail({
      to: email,
      template: 'audit-complete',
      data
    });
  }

  private async sendEmail(options: EmailOptions): Promise<void> {
    const template = this.templates.get(options.template);
    if (!template) {
      throw new Error(`Email template ${options.template} not found`);
    }

    try {
      // Apply template data
      const html = template.html(options.data);
      const text = template.text(options.data);
      const subject = handlebars.compile(template.subject)(options.data);

      // Send email
      await this.transporter.sendMail({
        from: process.env.EMAIL_FROM,
        to: options.to,
        subject,
        text,
        html
      });
    } catch (error) {
      console.error('Failed to send email:', error);
      throw new Error('Failed to send email');
    }
  }

  public async verifyConnection(): Promise<boolean> {
    try {
      await this.transporter.verify();
      return true;
    } catch (error) {
      console.error('Email service verification failed:', error);
      return false;
    }
  }
}

// Error handling class
export class EmailError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'EmailError';
  }
}

// Create and export singleton instance
const emailConfig: EmailConfig = {
  host: process.env.EMAIL_HOST || 'smtp.example.com',
  port: parseInt(process.env.EMAIL_PORT || '587'),
  secure: process.env.EMAIL_SECURE === 'true',
  auth: {
    user: process.env.EMAIL_USER || '',
    pass: process.env.EMAIL_PASS || ''
  },
  from: process.env.EMAIL_FROM || 'noreply@example.com'
};

export const emailService = new EmailService(emailConfig);

----- End of backend\src\services\emailService.ts -----



----- Start of backend\src\services\notificationsService.ts -----

// backend/src/services/notificationService.ts

import { Pool } from 'pg';
import { emailService } from './emailService';

interface NotificationPreferences {
  email: boolean;
  inApp: boolean;
  push: boolean;
  frequency: 'instant' | 'daily' | 'weekly';
  categories: string[];
}

interface Notification {
  id: string;
  userId: string;
  type: string;
  title: string;
  message: string;
  metadata?: Record<string, any>;
  priority: 'high' | 'medium' | 'low';
  createdAt: Date;
  readAt?: Date;
  deliveredAt?: Date;
}

export class NotificationService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  /**
   * Create and send a new notification
   */
  async sendNotification(
    userId: string,
    type: string,
    title: string,
    message: string,
    metadata?: Record<string, any>,
    priority: 'high' | 'medium' | 'low' = 'medium'
  ): Promise<string> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      // Get user preferences
      const prefsResult = await client.query(
        'SELECT notification_preferences FROM users WHERE id = $1',
        [userId]
      );

      const preferences: NotificationPreferences = prefsResult.rows[0]?.notification_preferences || {
        email: true,
        inApp: true,
        push: false,
        frequency: 'instant',
        categories: ['all']
      };

      // Create notification record
      const result = await client.query(
        `INSERT INTO notifications (
          user_id, type, title, message, metadata, priority, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)
        RETURNING id`,
        [userId, type, title, message, metadata, priority]
      );

      const notificationId = result.rows[0].id;

      // Handle delivery based on preferences
      if (preferences.inApp) {
        await this.deliverInAppNotification(notificationId, userId);
      }

      if (preferences.email && this.shouldSendEmail(type, preferences)) {
        await this.deliverEmailNotification(
          userId,
          title,
          message,
          type,
          metadata
        );
      }

      if (preferences.push) {
        await this.deliverPushNotification(
          userId,
          title,
          message,
          type,
          metadata
        );
      }

      await client.query('COMMIT');
      return notificationId;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Get user's notifications with pagination
   */
  async getUserNotifications(
    userId: string,
    page: number = 1,
    limit: number = 20
  ): Promise<{ notifications: Notification[]; total: number }> {
    const offset = (page - 1) * limit;

    const [notifications, count] = await Promise.all([
      this.pool.query(
        `SELECT * FROM notifications
         WHERE user_id = $1
         ORDER BY created_at DESC
         LIMIT $2 OFFSET $3`,
        [userId, limit, offset]
      ),
      this.pool.query(
        'SELECT COUNT(*) FROM notifications WHERE user_id = $1',
        [userId]
      )
    ]);

    return {
      notifications: notifications.rows,
      total: parseInt(count.rows[0].count)
    };
  }

  /**
   * Mark notifications as read
   */
  async markAsRead(notificationIds: string[], userId: string): Promise<void> {
    await this.pool.query(
      `UPDATE notifications
       SET read_at = CURRENT_TIMESTAMP
       WHERE id = ANY($1) AND user_id = $2`,
      [notificationIds, userId]
    );
  }

  /**
   * Update user notification preferences
   */
  async updatePreferences(
    userId: string,
    preferences: Partial<NotificationPreferences>
  ): Promise<NotificationPreferences> {
    const result = await this.pool.query(
      `UPDATE users
       SET notification_preferences = notification_preferences || $1
       WHERE id = $2
       RETURNING notification_preferences`,
      [preferences, userId]
    );

    return result.rows[0].notification_preferences;
  }

  /**
   * Send batch notifications (e.g., weekly digests)
   */
  async sendBatchNotifications(): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      // Get users with pending digest notifications
      const users = await client.query(
        `SELECT id, email, notification_preferences
         FROM users
         WHERE notification_preferences->>'frequency' = 'weekly'
         AND EXTRACT(DOW FROM CURRENT_TIMESTAMP) = 0`  // Send on Sundays
      );

      for (const user of users.rows) {
        const pendingNotifications = await client.query(
          `SELECT * FROM notifications
           WHERE user_id = $1
           AND created_at >= CURRENT_TIMESTAMP - INTERVAL '7 days'
           AND delivered_at IS NULL`,
          [user.id]
        );

        if (pendingNotifications.rows.length > 0) {
          await this.sendDigestEmail(
            user.id,
            user.email,
            pendingNotifications.rows
          );

          // Mark notifications as delivered
          await client.query(
            `UPDATE notifications
             SET delivered_at = CURRENT_TIMESTAMP
             WHERE id = ANY($1)`,
            [pendingNotifications.rows.map(n => n.id)]
          );
        }
      }

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Clean up old notifications
   */
  async cleanupOldNotifications(daysToKeep: number = 90): Promise<void> {
    await this.pool.query(
      `DELETE FROM notifications
       WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '${daysToKeep} days'`
    );
  }

  // Private helper methods

  private async deliverInAppNotification(
    notificationId: string,
    userId: string
  ): Promise<void> {
    await this.pool.query(
      `UPDATE notifications
       SET delivered_at = CURRENT_TIMESTAMP
       WHERE id = $1`,
      [notificationId]
    );
  }

  private async deliverEmailNotification(
    userId: string,
    title: string,
    message: string,
    type: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    const userResult = await this.pool.query(
      'SELECT email, full_name FROM users WHERE id = $1',
      [userId]
    );

    if (userResult.rows.length === 0) return;

    const { email, full_name } = userResult.rows[0];

    switch (type) {
      case 'audit_complete':
        await emailService.sendAuditCompleteEmail(
          email,
          metadata?.auditId,
          metadata?.recommendations
        );
        break;
      case 'recommendation':
        // TODO: Implement recommendation email template
        break;
      default:
        // Send generic notification email
        await emailService.sendEmail({
          to: email,
          template: 'notification',
          data: {
            name: full_name,
            title,
            message,
            type
          }
        });
    }
  }

  private async deliverPushNotification(
    userId: string,
    title: string,
    message: string,
    type: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    // TODO: Implement push notification delivery
    // This would integrate with a service like Firebase Cloud Messaging
    console.log('Push notification delivery not implemented yet');
  }

  private async sendDigestEmail(
    userId: string,
    email: string,
    notifications: Notification[]
  ): Promise<void> {
    await emailService.sendEmail({
      to: email,
      template: 'weekly-digest',
      data: {
        notifications,
        summary: this.generateDigestSummary(notifications)
      }
    });
  }

  private generateDigestSummary(notifications: Notification[]): any {
    // Group notifications by type and generate summary stats
    const summary = {
      total: notifications.length,
      byType: {} as Record<string, number>,
      highPriority: notifications.filter(n => n.priority === 'high').length
    };

    notifications.forEach(notification => {
      summary.byType[notification.type] = (summary.byType[notification.type] || 0) + 1;
    });

    return summary;
  }

  private shouldSendEmail(type: string, preferences: NotificationPreferences): boolean {
    if (!preferences.categories.includes('all') &&
        !preferences.categories.includes(type)) {
      return false;
    }

    return preferences.frequency === 'instant' ||
           (preferences.frequency === 'daily' && type === 'high_priority') ||
           preferences.frequency === 'weekly';
  }
}

// Error handling
export class NotificationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'NotificationError';
  }
}

----- End of backend\src\services\notificationsService.ts -----



----- Start of backend\src\services\productDataService.ts -----

// src/services/productDataService.ts
import Papa from 'papaparse';
import { Product, ProductFilters } from '../types/product';

class ProductDataService {
  private products: Product[] = [];

  async loadProductsFromCSV(file: string) {
    try {
      console.log('Attempting to load file:', file);

      // Use fetch instead of fs
      const response = await fetch(file);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const csvData = await response.text();
      console.log('CSV data loaded, first 100 chars:', csvData.substring(0, 100));

      const results = Papa.parse(csvData, {
        header: true,
        skipEmptyLines: true,
        transformHeader: (header) => {
          console.log('Processing header:', header);
          // Convert spaces and special characters to camelCase
          return header
            .toLowerCase()
            .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase());
        },
      });

      console.log('Papa Parse results:', {
        rows: results.data.length,
        errors: results.errors,
        meta: results.meta
      });

      if (results.errors && results.errors.length > 0) {
        console.error('Papa Parse errors:', results.errors);
        throw new Error('CSV parsing errors occurred');
      }

      this.products = results.data.map((row: any, index) => {
        try {
          // Parse features string into array
          const features = row.features
            ? row.features.split('\n').filter(Boolean).map((f: string) => f.trim())
            : [];

          // Extract specifications from description
          const specifications: { [key: string]: string } = {};
          if (row.description) {
            row.description.split('\n').forEach((line: string) => {
              const [key, value] = line.split(':').map(s => s.trim());
              if (key && value) {
                specifications[key] = value;
              }
            });
          }

          return {
            id: row.energyStarUniqueId || String(index + 1),
            productUrl: row.productUrl || '',
            mainCategory: row.mainCategory || 'Uncategorized',
            subCategory: row.subCategory || 'General',
            name: row.productName || 'Unknown Product',
            model: row.model || '',
            description: row.description || '',
            efficiency: row.efficiency || '',
            features: features,
            marketInfo: row.market || '',
            energyStarId: row.energyStarUniqueId || '',
            upcCodes: row.upcCodes || '',
            additionalModels: row.additionalModelNamesAndOrNumbers || '',
            pdfUrl: row.pdfFileUrl || '',
            specifications
          };
        } catch (err) {
          console.error(`Error processing row ${index}:`, row, err);
          throw err;
        }
      });

      console.log('Successfully loaded products:', this.products.length);
      return true;
    } catch (error) {
      const err = error as Error;
      console.error('Error details:', {
        name: err.name,
        message: err.message,
        stack: err.stack
      });
      throw new Error(`Failed to load products: ${err.message}`);
    }
  }

  async getProducts(filters?: ProductFilters): Promise<Product[]> {
    let filteredProducts = [...this.products];

    if (filters) {
      if (filters.mainCategory) {
        filteredProducts = filteredProducts.filter(
          p => p.mainCategory.toLowerCase() === filters.mainCategory?.toLowerCase()
        );
      }

      if (filters.subCategory) {
        filteredProducts = filteredProducts.filter(
          p => p.subCategory.toLowerCase() === filters.subCategory?.toLowerCase()
        );
      }

      if (filters.search) {
        const searchLower = filters.search.toLowerCase();
        filteredProducts = filteredProducts.filter(p =>
          p.name.toLowerCase().includes(searchLower) ||
          p.description.toLowerCase().includes(searchLower) ||
          p.model.toLowerCase().includes(searchLower)
        );
      }
    }

    return filteredProducts;
  }

  async getProduct(id: string): Promise<Product | null> {
    return this.products.find(p => p.id === id) || null;
  }

  async getCategories(): Promise<{ main: string[]; sub: { [key: string]: string[] } }> {
    const categories = {
      main: [] as string[],
      sub: {} as { [key: string]: string[] }
    };

    this.products.forEach(product => {
      if (!categories.main.includes(product.mainCategory)) {
        categories.main.push(product.mainCategory);
        categories.sub[product.mainCategory] = [];
      }

      if (!categories.sub[product.mainCategory]!.includes(product.subCategory)) {
        categories.sub[product.mainCategory]!.push(product.subCategory);
      }
    });

    return categories;
  }
}

export default ProductDataService;

----- End of backend\src\services\productDataService.ts -----



----- Start of backend\src\services\productService.ts -----

// src/services/productService.ts

import { Product, ProductFilters } from '../types/product';

// Mock data - replace with actual API calls later
const mockProducts: Product[] = [
  {
    id: '1',
    name: 'Smart LED Bulb Pack',
    category: 'Lighting',
    energyRating: 'A+',
    price: 29.99,
    rebateAmount: 5,
    description: 'Energy-efficient LED bulbs with smart controls',
    imageUrl: '/api/placeholder/200/200',
    specifications: {
      'Wattage': '9W',
      'Lumens': '800',
      'Lifespan': '25000 hours',
      'Color Temperature': '2700K-6500K'
    },
    annualEnergySavings: 80,
    brand: 'EcoLight',
    modelNumber: 'EL-SB-100',
    warrantyYears: 3
  },
  {
    id: '2',
    name: 'Smart Thermostat Pro',
    category: 'HVAC',
    energyRating: 'A++',
    price: 199.99,
    rebateAmount: 30,
    description: 'AI-powered thermostat that learns your schedule',
    imageUrl: '/api/placeholder/200/200',
    specifications: {
      'Display': 'HD Color Touch',
      'Wireless': 'Wi-Fi, Bluetooth',
      'Compatibility': 'Most HVAC systems',
      'Sensors': 'Temperature, Humidity, Occupancy'
    },
    annualEnergySavings: 150,
    brand: 'ClimateIQ',
    modelNumber: 'CIQ-200',
    warrantyYears: 2
  },
  // Add more mock products here
];

export const productService = {
  // Get all products with optional filtering
  getProducts: async (filters?: ProductFilters): Promise<Product[]> => {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 500));

    let filteredProducts = [...mockProducts];

    if (filters) {
      if (filters.category) {
        filteredProducts = filteredProducts.filter(p => p.category === filters.category);
      }

      if (filters.energyRating) {
        filteredProducts = filteredProducts.filter(p => p.energyRating === filters.energyRating);
      }

      if (filters.priceRange) {
        filteredProducts = filteredProducts.filter(
          p => p.price >= filters.priceRange!.min && p.price <= filters.priceRange!.max
        );
      }

      if (filters.hasRebate) {
        filteredProducts = filteredProducts.filter(p => p.rebateAmount > 0);
      }

      if (filters.search) {
        const searchLower = filters.search.toLowerCase();
        filteredProducts = filteredProducts.filter(
          p => p.name.toLowerCase().includes(searchLower) ||
               p.description.toLowerCase().includes(searchLower) ||
               p.brand?.toLowerCase().includes(searchLower)
        );
      }
    }

    return filteredProducts;
  },

  // Get a single product by ID
  getProduct: async (id: string): Promise<Product | null> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return mockProducts.find(p => p.id === id) || null;
  },

  // Get product categories
  getCategories: async (): Promise<string[]> => {
    const categories = [...new Set(mockProducts.map(p => p.category))];
    return categories;
  }
};

export default productService;

----- End of backend\src\services\productService.ts -----



----- Start of backend\src\services\recommendationService.ts -----

// backend/src/services/recommendationService.ts

import { Pool } from 'pg';
import { Product } from '../types/product';
import { EnergyAuditData } from '../types/energyAudit';

export interface Recommendation {
  id: string;
  userId: string;
  productId: string;
  type: 'product' | 'improvement';
  priority: 'high' | 'medium' | 'low';
  reason: string;
  potentialSavings: number;
  createdAt: Date;
}

export class RecommendationService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  async generateRecommendations(userId: string, auditData: EnergyAuditData): Promise<Recommendation[]> {
    const recommendations: Recommendation[] = [];

    // Get user's energy profile
    const energyProfile = await this.analyzeEnergyProfile(auditData);

    // Get matching products
    const products = await this.findMatchingProducts(energyProfile);

    // Generate product recommendations
    for (const product of products) {
      const savings = await this.calculatePotentialSavings(product, auditData);

      if (savings > 0) {
        recommendations.push({
          id: crypto.randomUUID(),
          userId,
          productId: product.id,
          type: 'product',
          priority: this.calculatePriority(savings),
          reason: this.generateRecommendationReason(product, savings),
          potentialSavings: savings,
          createdAt: new Date()
        });
      }
    }

    return recommendations;
  }

  private async analyzeEnergyProfile(auditData: EnergyAuditData) {
    const profile = {
      heatingEfficiency: this.calculateHeatingEfficiency(auditData),
      coolingEfficiency: this.calculateCoolingEfficiency(auditData),
      insulationScore: this.calculateInsulationScore(auditData),
      windowEfficiency: this.calculateWindowEfficiency(auditData),
      applianceAge: this.getApplianceAge(auditData)
    };

    return profile;
  }

  private calculateHeatingEfficiency(auditData: EnergyAuditData): number {
    const { heatingSystem } = auditData.heatingCooling;
    let efficiency = 1.0;

    // Reduce efficiency based on system age
    if (heatingSystem.age > 15) efficiency *= 0.7;
    else if (heatingSystem.age > 10) efficiency *= 0.85;

    // Factor in fuel type efficiency
    const fuelEfficiency = {
      'natural-gas': 0.95,
      'oil': 0.85,
      'electric': 1.0,
      'propane': 0.90
    };
    efficiency *= fuelEfficiency[heatingSystem.fuelType] || 0.85;

    return efficiency;
  }

  private calculateCoolingEfficiency(auditData: EnergyAuditData): number {
    const { coolingSystem } = auditData.heatingCooling;
    let efficiency = 1.0;

    // Adjust based on system type and age
    if (coolingSystem.type === 'central') {
      if (coolingSystem.age > 10) efficiency *= 0.75;
      else if (coolingSystem.age > 5) efficiency *= 0.9;
    } else if (coolingSystem.type === 'window-unit') {
      efficiency *= 0.8;
    }

    return efficiency;
  }

  private calculateInsulationScore(auditData: EnergyAuditData): number {
    const { insulation } = auditData.currentConditions;
    const scores = {
      'poor': 0,
      'average': 1,
      'good': 2,
      'excellent': 3
    };

    return (
      scores[insulation.attic] +
      scores[insulation.walls] +
      scores[insulation.basement] +
      scores[insulation.floor]
    ) / 12; // Normalize to 0-1 scale
  }

  private calculateWindowEfficiency(auditData: EnergyAuditData): number {
    const { windowType, windowCondition } = auditData.currentConditions;

    const typeScore = {
      'single': 0.3,
      'double': 0.7,
      'triple': 1.0,
      'not-sure': 0.5
    }[windowType];

    const conditionScore = {
      'poor': 0.3,
      'fair': 0.6,
      'good': 0.8,
      'excellent': 1.0
    }[windowCondition];

    return (typeScore + conditionScore) / 2;
  }

  private getApplianceAge(auditData: EnergyAuditData): number {
    // Average age of major appliances
    return auditData.heatingCooling.heatingSystem.age;
  }

  private async findMatchingProducts(energyProfile: any): Promise<Product[]> {
    // Query database for products matching the energy profile
    const result = await this.pool.query(
      `SELECT * FROM products WHERE
       category = ANY($1) AND
       efficiency_rating >= $2
       ORDER BY efficiency_rating DESC
       LIMIT 10`,
      [this.determineRelevantCategories(energyProfile),
       this.calculateMinEfficiencyThreshold(energyProfile)]
    );

    return result.rows;
  }

  private determineRelevantCategories(profile: any): string[] {
    const categories = [];

    if (profile.heatingEfficiency < 0.8) categories.push('heating');
    if (profile.coolingEfficiency < 0.8) categories.push('cooling');
    if (profile.insulationScore < 0.7) categories.push('insulation');
    if (profile.windowEfficiency < 0.6) categories.push('windows');

    return categories;
  }

  private calculateMinEfficiencyThreshold(profile: any): number {
    // Dynamic threshold based on current efficiency levels
    return Math.min(...Object.values(profile)) + 0.2;
  }

  private async calculatePotentialSavings(product: Product, auditData: EnergyAuditData): Promise<number> {
    // Calculate potential annual savings based on product specs and current usage
    const baselineUsage = this.calculateBaselineUsage(auditData);
    const projectedUsage = this.calculateProjectedUsage(baselineUsage, product);
    const energyRate = await this.getEnergyRate(auditData.basicInfo.address);

    return (baselineUsage - projectedUsage) * energyRate;
  }

  private calculateBaselineUsage(auditData: EnergyAuditData): number {
    return auditData.energyConsumption.monthlyBill * 12;
  }

  private calculateProjectedUsage(baselineUsage: number, product: Product): number {
    const efficiencyImprovement = parseFloat(product.efficiency.replace(/[^0-9.]/g, '')) / 100;
    return baselineUsage * (1 - efficiencyImprovement);
  }

  private async getEnergyRate(address: string): Promise<number> {
    // Lookup energy rate by location
    // For now, using US average
    return 0.14; // $0.14 per kWh
  }

  private calculatePriority(savings: number): 'high' | 'medium' | 'low' {
    if (savings > 500) return 'high';
    if (savings > 200) return 'medium';
    return 'low';
  }

  private generateRecommendationReason(product: Product, savings: number): string {
    return `Based on your energy audit, replacing your current ${product.mainCategory.toLowerCase()} ` +
           `with this ${product.name} could save you $${Math.round(savings)} annually`;
  }

  async storeRecommendations(recommendations: Recommendation[]): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      for (const rec of recommendations) {
        await client.query(
          `INSERT INTO recommendations (
            id, user_id, product_id, type, priority,
            reason, potential_savings, created_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
          [rec.id, rec.userId, rec.productId, rec.type, rec.priority,
           rec.reason, rec.potentialSavings, rec.createdAt]
        );
      }

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async getUserRecommendations(userId: string): Promise<Recommendation[]> {
    const result = await this.pool.query(
      `SELECT * FROM recommendations
       WHERE user_id = $1
       ORDER BY created_at DESC`,
      [userId]
    );
    return result.rows;
  }
}

----- End of backend\src\services\recommendationService.ts -----



----- Start of backend\src\services\searchService.ts -----

// backend/src/services/searchService.ts

import { Pool } from 'pg';
import { Product } from '../types/product';

interface SearchFilters {
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  efficiencyRating?: string;
  brands?: string[];
  features?: string[];
  hasRebate?: boolean;
}

interface SearchOptions {
  limit?: number;
  offset?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

interface SearchResult<T> {
  items: T[];
  total: number;
  page: number;
  totalPages: number;
}

export class SearchService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  /**
   * Search products with filters and pagination
   */
  async searchProducts(
    query: string,
    filters: SearchFilters = {},
    options: SearchOptions = {}
  ): Promise<SearchResult<Product>> {
    const {
      limit = 20,
      offset = 0,
      sortBy = 'relevance',
      sortOrder = 'desc'
    } = options;

    try {
      // Build the base query
      let queryString = `
        SELECT *,
          ts_rank_cd(to_tsvector('english',
            name || ' ' || description || ' ' ||
            COALESCE(features::text, '') || ' ' ||
            COALESCE(specifications::text, '')
          ), plainto_tsquery('english', $1)) as relevance
        FROM products
        WHERE 1=1
      `;

      const queryParams: any[] = [query];
      let paramCount = 2;

      // Add filters
      const { whereClause, filterParams } = this.buildFilterClause(filters, paramCount);
      queryString += whereClause;
      queryParams.push(...filterParams);
      paramCount += filterParams.length;

      // Add full-text search condition if query is not empty
      if (query.trim()) {
        queryString += `
          AND to_tsvector('english',
            name || ' ' || description || ' ' ||
            COALESCE(features::text, '') || ' ' ||
            COALESCE(specifications::text, '')
          ) @@ plainto_tsquery('english', $1)
        `;
      }

      // Add sorting
      queryString += this.buildSortClause(sortBy, sortOrder);

      // Add pagination
      queryString += ` LIMIT $${paramCount} OFFSET $${paramCount + 1}`;
      queryParams.push(limit, offset);

      // Execute search query
      const [results, countResult] = await Promise.all([
        this.pool.query(queryString, queryParams),
        this.pool.query(
          `SELECT COUNT(*) FROM (${queryString.split('LIMIT')[0]}) as count_query`,
          queryParams.slice(0, -2)
        )
      ]);

      const total = parseInt(countResult.rows[0].count);

      return {
        items: results.rows,
        total,
        page: Math.floor(offset / limit) + 1,
        totalPages: Math.ceil(total / limit)
      };
    } catch (error) {
      throw new SearchError(`Failed to search products: ${error.message}`);
    }
  }

  /**
   * Search recommendations
   */
  async searchRecommendations(
    userId: string,
    query: string,
    options: SearchOptions = {}
  ): Promise<SearchResult<any>> {
    const {
      limit = 20,
      offset = 0,
      sortBy = 'created_at',
      sortOrder = 'desc'
    } = options;

    try {
      const queryString = `
        SELECT r.*,
          CASE WHEN r.implemented THEN 2
               WHEN r.priority = 'high' THEN 1
               ELSE 0
          END as relevance_score
        FROM recommendations r
        WHERE r.user_id = $1
        AND (
          r.description ILIKE $2
          OR r.category ILIKE $2
          OR EXISTS (
            SELECT 1 FROM jsonb_array_elements(r.recommended_products) as p
            WHERE p->>'name' ILIKE $2
          )
        )
        ORDER BY
          relevance_score DESC,
          ${this.getOrderByClause(sortBy, sortOrder)}
        LIMIT $3 OFFSET $4
      `;

      const [results, countResult] = await Promise.all([
        this.pool.query(queryString, [userId, `%${query}%`, limit, offset]),
        this.pool.query(
          `SELECT COUNT(*) FROM recommendations r
           WHERE r.user_id = $1
           AND (
             r.description ILIKE $2
             OR r.category ILIKE $2
             OR EXISTS (
               SELECT 1 FROM jsonb_array_elements(r.recommended_products) as p
               WHERE p->>'name' ILIKE $2
             )
           )`,
          [userId, `%${query}%`]
        )
      ]);

      const total = parseInt(countResult.rows[0].count);

      return {
        items: results.rows,
        total,
        page: Math.floor(offset / limit) + 1,
        totalPages: Math.ceil(total / limit)
      };
    } catch (error) {
      throw new SearchError(`Failed to search recommendations: ${error.message}`);
    }
  }

  /**
   * Search energy audit reports
   */
  async searchAuditReports(
    userId: string,
    query: string,
    options: SearchOptions = {}
  ): Promise<SearchResult<any>> {
    const {
      limit = 20,
      offset = 0,
      sortBy = 'completed_at',
      sortOrder = 'desc'
    } = options;

    try {
      const queryString = `
        SELECT ea.*,
          ts_rank_cd(to_tsvector('english',
            COALESCE(ea.home_details::text, '') || ' ' ||
            COALESCE(ea.current_conditions::text, '') || ' ' ||
            COALESCE(ea.heating_cooling::text, '')
          ), plainto_tsquery('english', $2)) as relevance
        FROM energy_audits ea
        WHERE ea.user_id = $1
        AND to_tsvector('english',
          COALESCE(ea.home_details::text, '') || ' ' ||
          COALESCE(ea.current_conditions::text, '') || ' ' ||
          COALESCE(ea.heating_cooling::text, '')
        ) @@ plainto_tsquery('english', $2)
        ORDER BY
          ${this.getOrderByClause(sortBy, sortOrder)}
        LIMIT $3 OFFSET $4
      `;

      const [results, countResult] = await Promise.all([
        this.pool.query(queryString, [userId, query, limit, offset]),
        this.pool.query(
          `SELECT COUNT(*) FROM energy_audits ea
           WHERE ea.user_id = $1
           AND to_tsvector('english',
             COALESCE(ea.home_details::text, '') || ' ' ||
             COALESCE(ea.current_conditions::text, '') || ' ' ||
             COALESCE(ea.heating_cooling::text, '')
           ) @@ plainto_tsquery('english', $2)`,
          [userId, query]
        )
      ]);

      const total = parseInt(countResult.rows[0].count);

      return {
        items: results.rows,
        total,
        page: Math.floor(offset / limit) + 1,
        totalPages: Math.ceil(total / limit)
      };
    } catch (error) {
      throw new SearchError(`Failed to search audit reports: ${error.message}`);
    }
  }

  // Private helper methods

  private buildFilterClause(filters: SearchFilters, startParamCount: number): {
    whereClause: string;
    filterParams: any[];
  } {
    const clauses: string[] = [];
    const params: any[] = [];
    let paramCount = startParamCount;

    if (filters.category) {
      clauses.push(`category = $${paramCount}`);
      params.push(filters.category);
      paramCount++;
    }

    if (filters.minPrice !== undefined) {
      clauses.push(`price >= $${paramCount}`);
      params.push(filters.minPrice);
      paramCount++;
    }

    if (filters.maxPrice !== undefined) {
      clauses.push(`price <= $${paramCount}`);
      params.push(filters.maxPrice);
      paramCount++;
    }

    if (filters.efficiencyRating) {
      clauses.push(`efficiency_rating = $${paramCount}`);
      params.push(filters.efficiencyRating);
      paramCount++;
    }

    if (filters.brands?.length) {
      clauses.push(`brand = ANY($${paramCount})`);
      params.push(filters.brands);
      paramCount++;
    }

    if (filters.features?.length) {
      clauses.push(`features ?| $${paramCount}`);
      params.push(filters.features);
      paramCount++;
    }

    if (filters.hasRebate !== undefined) {
      clauses.push(`rebate_amount ${filters.hasRebate ? '>' : '='} 0`);
    }

    return {
      whereClause: clauses.length ? ` AND ${clauses.join(' AND ')}` : '',
      filterParams: params
    };
  }

  private buildSortClause(sortBy: string, sortOrder: 'asc' | 'desc'): string {
    switch (sortBy) {
      case 'price':
        return ` ORDER BY price ${sortOrder}`;
      case 'efficiency':
        return ` ORDER BY efficiency_rating ${sortOrder}`;
      case 'relevance':
        return ` ORDER BY relevance ${sortOrder}, name ASC`;
      default:
        return ` ORDER BY name ASC`;
    }
  }

  private getOrderByClause(sortBy: string, sortOrder: 'asc' | 'desc'): string {
    const validColumns = ['created_at', 'completed_at', 'status', 'priority'];
    return validColumns.includes(sortBy) ?
      `${sortBy} ${sortOrder}` :
      'created_at DESC';
  }
}

export class SearchError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'SearchError';
  }
}

----- End of backend\src\services\searchService.ts -----



----- Start of backend\src\services\userAuthService.ts -----

// src/services/userAuthService.ts

import { Pool } from 'pg';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';

const SALT_ROUNDS = 12;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const JWT_EXPIRES_IN = '24h';

export class UserAuthService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  async registerUser(email: string, password: string, fullName: string, phone?: string, address?: string) {
    try {
      // Check if user already exists
      const existingUser = await this.pool.query(
        'SELECT id FROM users WHERE email = $1',
        [email]
      );

      if (existingUser.rows.length > 0) {
        throw new Error('User already exists');
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);

      // Insert new user
      const result = await this.pool.query(
        `INSERT INTO users (id, email, password_hash, full_name, phone, address)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING id, email, full_name, created_at`,
        [uuidv4(), email, passwordHash, fullName, phone, address]
      );

      // Generate JWT token
      const token = this.generateToken(result.rows[0]);

      return {
        user: result.rows[0],
        token
      };
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Registration failed: ${error.message}`);
      }
      throw new Error('Registration failed');
    }
  }

  async loginUser(email: string, password: string) {
    try {
      // Get user by email
      const result = await this.pool.query(
        'SELECT * FROM users WHERE email = $1',
        [email]
      );

      const user = result.rows[0];

      if (!user) {
        throw new Error('User not found');
      }

      // Verify password
      const isValid = await bcrypt.compare(password, user.password_hash);

      if (!isValid) {
        throw new Error('Invalid password');
      }

      // Update last login
      await this.pool.query(
        'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1',
        [user.id]
      );

      // Generate token
      const token = this.generateToken(user);

      return {
        user: {
          id: user.id,
          email: user.email,
          fullName: user.full_name,
          role: user.role
        },
        token
      };
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Login failed: ${error.message}`);
      }
      throw new Error('Login failed');
    }
  }

  async verifyToken(token: string) {
    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      return decoded;
    } catch (error) {
      throw new Error('Invalid token');
    }
  }

  async updateUserProfile(userId: string, updates: {
    fullName?: string;
    phone?: string;
    address?: string;
  }) {
    try {
      const setClause = [];
      const values = [];
      let paramCount = 1;

      if (updates.fullName) {
        setClause.push(`full_name = $${paramCount}`);
        values.push(updates.fullName);
        paramCount++;
      }

      if (updates.phone) {
        setClause.push(`phone = $${paramCount}`);
        values.push(updates.phone);
        paramCount++;
      }

      if (updates.address) {
        setClause.push(`address = $${paramCount}`);
        values.push(updates.address);
        paramCount++;
      }

      if (setClause.length === 0) {
        throw new Error('No updates provided');
      }

      values.push(userId);

      const query = `
        UPDATE users
        SET ${setClause.join(', ')}, updated_at = CURRENT_TIMESTAMP
        WHERE id = $${paramCount}
        RETURNING id, email, full_name, phone, address, role, updated_at
      `;

      const result = await this.pool.query(query, values);

      if (result.rows.length === 0) {
        throw new Error('User not found');
      }

      return result.rows[0];
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Profile update failed: ${error.message}`);
      }
      throw new Error('Profile update failed');
    }
  }

  private generateToken(user: any) {
    return jwt.sign(
      {
        userId: user.id,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );
  }
}

// Error types for better error handling
export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

// Input validation functions
export const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const validatePassword = (password: string): boolean => {
  // Minimum 8 characters, at least one uppercase, one lowercase, one number
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
  return passwordRegex.test(password);
};

----- End of backend\src\services\userAuthService.ts -----



----- Start of backend\src\services\userService.ts -----

// backend/src/services/userService.ts

import { Pool } from 'pg';
import bcrypt from 'bcrypt';
import { AuthError } from './auth/AuthService';

interface UserProfile {
  id: string;
  email: string;
  fullName: string;
  phone?: string;
  address?: string;
  energyProfile?: EnergyProfile;
  preferences: UserPreferences;
  createdAt: Date;
  updatedAt: Date;
}

interface EnergyProfile {
  utilityProvider: string;
  averageMonthlyBill: number;
  homeSize: number;
  homeType: string;
  climateZone: string;
}

interface UserPreferences {
  emailNotifications: boolean;
  theme: 'light' | 'dark';
  currency: string;
  unitSystem: 'imperial' | 'metric';
}

export class UserService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  async getUserProfile(userId: string): Promise<UserProfile> {
    const result = await this.pool.query(
      `SELECT
        u.id, u.email, u.full_name, u.phone, u.address,
        u.created_at, u.updated_at,
        e.utility_provider, e.average_monthly_bill,
        e.home_size, e.home_type, e.climate_zone,
        p.email_notifications, p.theme, p.currency, p.unit_system
       FROM users u
       LEFT JOIN energy_profiles e ON u.id = e.user_id
       LEFT JOIN user_preferences p ON u.id = p.user_id
       WHERE u.id = $1`,
      [userId]
    );

    if (result.rows.length === 0) {
      throw new Error('User not found');
    }

    return this.mapRowToUserProfile(result.rows[0]);
  }

  async updateProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      if (updates.fullName || updates.phone || updates.address) {
        await client.query(
          `UPDATE users
           SET full_name = COALESCE($1, full_name),
               phone = COALESCE($2, phone),
               address = COALESCE($3, address),
               updated_at = CURRENT_TIMESTAMP
           WHERE id = $4`,
          [updates.fullName, updates.phone, updates.address, userId]
        );
      }

      if (updates.energyProfile) {
        await client.query(
          `INSERT INTO energy_profiles (
            user_id, utility_provider, average_monthly_bill,
            home_size, home_type, climate_zone
          ) VALUES ($1, $2, $3, $4, $5, $6)
          ON CONFLICT (user_id) DO UPDATE SET
            utility_provider = EXCLUDED.utility_provider,
            average_monthly_bill = EXCLUDED.average_monthly_bill,
            home_size = EXCLUDED.home_size,
            home_type = EXCLUDED.home_type,
            climate_zone = EXCLUDED.climate_zone`,
          [
            userId,
            updates.energyProfile.utilityProvider,
            updates.energyProfile.averageMonthlyBill,
            updates.energyProfile.homeSize,
            updates.energyProfile.homeType,
            updates.energyProfile.climateZone
          ]
        );
      }

      if (updates.preferences) {
        await client.query(
          `INSERT INTO user_preferences (
            user_id, email_notifications, theme, currency, unit_system
          ) VALUES ($1, $2, $3, $4, $5)
          ON CONFLICT (user_id) DO UPDATE SET
            email_notifications = EXCLUDED.email_notifications,
            theme = EXCLUDED.theme,
            currency = EXCLUDED.currency,
            unit_system = EXCLUDED.unit_system`,
          [
            userId,
            updates.preferences.emailNotifications,
            updates.preferences.theme,
            updates.preferences.currency,
            updates.preferences.unitSystem
          ]
        );
      }

      await client.query('COMMIT');
      return await this.getUserProfile(userId);

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async updatePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {
    const result = await this.pool.query(
      'SELECT password_hash FROM users WHERE id = $1',
      [userId]
    );

    if (result.rows.length === 0) {
      throw new AuthError('User not found');
    }

    const validPassword = await bcrypt.compare(currentPassword, result.rows[0].password_hash);
    if (!validPassword) {
      throw new AuthError('Invalid current password');
    }

    const newPasswordHash = await bcrypt.hash(newPassword, 12);
    await this.pool.query(
      'UPDATE users SET password_hash = $1 WHERE id = $2',
      [newPasswordHash, userId]
    );
  }

  async trackEnergyUsage(userId: string, usage: {
    month: string;
    consumption: number;
    cost: number;
  }): Promise<void> {
    await this.pool.query(
      `INSERT INTO energy_usage (
        user_id, month, consumption, cost, created_at
      ) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)`,
      [userId, usage.month, usage.consumption, usage.cost]
    );
  }

  async getEnergyUsageHistory(userId: string, months: number = 12) {
    const result = await this.pool.query(
      `SELECT month, consumption, cost
       FROM energy_usage
       WHERE user_id = $1
       ORDER BY month DESC
       LIMIT $2`,
      [userId, months]
    );
    return result.rows;
  }

  async deleteAccount(userId: string, password: string): Promise<void> {
    const result = await this.pool.query(
      'SELECT password_hash FROM users WHERE id = $1',
      [userId]
    );

    if (result.rows.length === 0) {
      throw new AuthError('User not found');
    }

    const validPassword = await bcrypt.compare(password, result.rows[0].password_hash);
    if (!validPassword) {
      throw new AuthError('Invalid password');
    }

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      // Delete related data first
      await client.query('DELETE FROM energy_profiles WHERE user_id = $1', [userId]);
      await client.query('DELETE FROM user_preferences WHERE user_id = $1', [userId]);
      await client.query('DELETE FROM energy_usage WHERE user_id = $1', [userId]);
      await client.query('DELETE FROM energy_audits WHERE user_id = $1', [userId]);

      // Finally delete user
      await client.query('DELETE FROM users WHERE id = $1', [userId]);

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  private mapRowToUserProfile(row: any): UserProfile {
    return {
      id: row.id,
      email: row.email,
      fullName: row.full_name,
      phone: row.phone,
      address: row.address,
      energyProfile: row.utility_provider ? {
        utilityProvider: row.utility_provider,
        averageMonthlyBill: row.average_monthly_bill,
        homeSize: row.home_size,
        homeType: row.home_type,
        climateZone: row.climate_zone
      } : undefined,
      preferences: {
        emailNotifications: row.email_notifications,
        theme: row.theme || 'light',
        currency: row.currency || 'USD',
        unitSystem: row.unit_system || 'imperial'
      },
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
}

----- End of backend\src\services\userService.ts -----



----- Start of backend\src\types\analytics.ts -----

// backend/src/types/analytics.ts

/**
 * Platform-wide metrics interface
 */
export interface PlatformMetrics {
    activeUsers: {
      daily: number;
      weekly: number;
      monthly: number;
      total: number;
      growth: number;  // Percentage growth from previous period
    };
    engagement: {
      avgSessionDuration: number;
      avgPageViews: number;
      bounceRate: number;
      returnRate: number;
    };
    energyImpact: {
      totalSavingsKwh: number;
      totalSavingsCost: number;
      carbonReduction: number;  // In metric tons
      averageSavingsPerUser: number;
    };
    productMetrics: {
      totalProducts: number;
      topCategories: Array<{
        category: string;
        views: number;
        conversions: number;
      }>;
      avgProductRating: number;
    };
    auditMetrics: {
      totalAudits: number;
      completionRate: number;
      averageScore: number;
      recommendationsImplemented: number;
    };
  }

  /**
   * User-specific analytics data
   */
  export interface UserAnalytics {
    userId: string;
    profile: {
      registrationDate: Date;
      lastActive: Date;
      completedAudits: number;
      totalSavings: number;
      achievementScore: number;
    };
    engagement: {
      sessionCount: number;
      totalTimeSpent: number;
      lastNSessions: Array<{
        date: Date;
        duration: number;
        actions: number;
      }>;
    };
    energyData: {
      baselineUsage: number;
      currentUsage: number;
      savingsPercentage: number;
      implementedRecommendations: number;
    };
    productInteractions: Array<{
      productId: string;
      views: number;
      lastViewed: Date;
      savedToList: boolean;
      purchased?: boolean;
    }>;
  }

  /**
   * Analytics event types
   */
  export type AnalyticsEventType =
    // User events
    | 'user_registration'
    | 'user_login'
    | 'user_logout'
    | 'profile_update'
    | 'preferences_change'

    // Page events
    | 'page_view'
    | 'page_exit'
    | 'scroll_depth'
    | 'time_on_page'

    // Product events
    | 'product_view'
    | 'product_search'
    | 'product_filter'
    | 'product_save'
    | 'product_share'
    | 'product_purchase'

    // Audit events
    | 'audit_start'
    | 'audit_step_complete'
    | 'audit_abandon'
    | 'audit_complete'
    | 'recommendation_view'
    | 'recommendation_implement'

    // Feature events
    | 'feature_interaction'
    | 'tool_usage'
    | 'calculator_usage'
    | 'report_download'

    // Error events
    | 'error_occurrence'
    | 'form_error'
    | 'api_error';

  /**
   * Analytics event data
   */
  export interface AnalyticsEvent {
    id: string;
    type: AnalyticsEventType;
    userId?: string;
    sessionId: string;
    timestamp: Date;
    properties: Record<string, any>;
    metadata?: {
      userAgent?: string;
      ipAddress?: string;
      referrer?: string;
      path?: string;
    };
  }

  /**
   * Session tracking interface
   */
  export interface AnalyticsSession {
    id: string;
    userId?: string;
    startTime: Date;
    endTime?: Date;
    duration?: number;
    events: AnalyticsEvent[];
    device: {
      type: 'desktop' | 'tablet' | 'mobile';
      browser: string;
      os: string;
    };
    location?: {
      country?: string;
      region?: string;
      city?: string;
    };
  }

  /**
   * Time periods for analytics queries
   */
  export type AnalyticsTimeframe =
    | 'hour'
    | 'day'
    | 'week'
    | 'month'
    | 'quarter'
    | 'year'
    | 'custom';

  /**
   * Analytics report configuration
   */
  export interface AnalyticsReportConfig {
    timeframe: AnalyticsTimeframe;
    metrics: string[];
    filters?: Record<string, any>;
    groupBy?: string[];
    sortBy?: string;
    limit?: number;
    format?: 'json' | 'csv' | 'pdf';
  }

  /**
   * Energy usage analytics
   */
  export interface EnergyAnalytics {
    userId: string;
    period: {
      start: Date;
      end: Date;
    };
    consumption: {
      total: number;
      byHour: number[];
      byDay: number[];
      byMonth: number[];
    };
    costs: {
      total: number;
      average: number;
      breakdown: Record<string, number>;
    };
    savings: {
      total: number;
      percentage: number;
      bySolution: Array<{
        recommendationId: string;
        amount: number;
      }>;
    };
    comparison: {
      similarHomes: number;
      regionalAverage: number;
      nationalAverage: number;
    };
  }

  /**
   * Product analytics
   */
  export interface ProductAnalytics {
    productId: string;
    views: {
      total: number;
      unique: number;
      byDate: Record<string, number>;
    };
    conversions: {
      total: number;
      rate: number;
      bySource: Record<string, number>;
    };
    recommendations: {
      appearanceCount: number;
      clickThroughRate: number;
      implementationRate: number;
    };
    feedback: {
      ratings: number[];
      averageRating: number;
      reviewCount: number;
    };
  }

  /**
   * Error tracking interface
   */
  export interface AnalyticsError {
    id: string;
    type: string;
    message: string;
    stack?: string;
    userId?: string;
    sessionId: string;
    timestamp: Date;
    context: {
      url?: string;
      component?: string;
      action?: string;
      additionalData?: Record<string, any>;
    };
    resolution?: {
      status: 'resolved' | 'investigating' | 'ignored';
      resolvedAt?: Date;
      resolution?: string;
    };
  }

  /**
   * Performance metrics interface
   */
  export interface PerformanceMetrics {
    apiLatency: {
      avg: number;
      p95: number;
      p99: number;
    };
    pageLoadTime: {
      avg: number;
      byPage: Record<string, number>;
    };
    errorRates: {
      api: number;
      client: number;
      byEndpoint: Record<string, number>;
    };
    resourceUtilization: {
      cpu: number;
      memory: number;
      storage: number;
    };
  }

  /**
   * Custom error types for analytics operations
   */
  export class AnalyticsError extends Error {
    constructor(
      message: string,
      public code: string,
      public details?: Record<string, any>
    ) {
      super(message);
      this.name = 'AnalyticsError';
    }
  }

  export class AnalyticsValidationError extends AnalyticsError {
    constructor(message: string, details?: Record<string, any>) {
      super(message, 'VALIDATION_ERROR', details);
      this.name = 'AnalyticsValidationError';
    }
  }

  export class AnalyticsTrackingError extends AnalyticsError {
    constructor(message: string, details?: Record<string, any>) {
      super(message, 'TRACKING_ERROR', details);
      this.name = 'AnalyticsTrackingError';
    }
  }

----- End of backend\src\types\analytics.ts -----



----- Start of backend\src\types\energyAudit.ts -----

// src/types/energyAudit.ts

export interface BasicInfo {
    fullName: string;
    email: string;
    phone?: string;
    address: string;
    auditDate: string;
  }

  export interface HomeDetails {
    yearBuilt: number;
    homeSize: number;
    numRooms: number;
    homeType: 'apartment' | 'single-family' | 'townhouse' | 'duplex' | 'other';
    numFloors: number;
    basementType: 'full' | 'partial' | 'crawlspace' | 'slab' | 'none' | 'other';
    basementHeating?: 'heated' | 'unheated' | 'partial';
  }

  export interface CurrentConditions {
    insulation: {
      attic: 'poor' | 'average' | 'good' | 'excellent' | 'not-sure';
      walls: 'poor' | 'average' | 'good' | 'excellent' | 'not-sure';
      basement: 'poor' | 'average' | 'good' | 'excellent' | 'not-sure';
      floor: 'poor' | 'average' | 'good' | 'excellent' | 'not-sure';
    };
    windowType: 'single' | 'double' | 'triple' | 'not-sure';
    numWindows: number;
    windowCondition: 'excellent' | 'good' | 'fair' | 'poor';
    weatherStripping: 'door-sweep' | 'foam' | 'metal' | 'none' | 'not-sure';
  }

  export interface HeatingCooling {
    heatingSystem: {
      type: 'furnace' | 'boiler' | 'heat-pump' | 'electric-baseboard' | 'other';
      fuelType: 'natural-gas' | 'oil' | 'electric' | 'propane' | 'other';
      age: number;
      lastService: string;
    };
    coolingSystem: {
      type: 'central' | 'window-unit' | 'portable' | 'none';
      age: number;
    };
  }

  export interface EnergyConsumption {
    powerConsumption: string; // e.g., "2-4kW"
    occupancyHours: {
      weekdays: '0-6' | '7-12' | '13-18' | '19-24';
      weekends: '0-6' | '7-12' | '13-18' | '19-24';
    };
    season: 'mild-winter' | 'moderate-winter' | 'mild-summer' | 'moderate-summer' | 'peak-summer' | 'spring-fall';
    occupancyPattern: string;
    monthlyBill: number;
    peakUsageTimes: string[];
  }

  export interface EnergyAuditData {
    basicInfo: BasicInfo;
    homeDetails: HomeDetails;
    currentConditions: CurrentConditions;
    heatingCooling: HeatingCooling;
    energyConsumption: EnergyConsumption;
    // Additional sections will be added as needed
  }

  // Validation functions
  export const validateBasicInfo = (data: BasicInfo): string[] => {
    const errors: string[] = [];

    if (!data.fullName.trim()) {
      errors.push('Full name is required');
    }

    if (!data.email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
      errors.push('Valid email is required');
    }

    if (data.phone && !data.phone.match(/^\+?[\d\s-]+$/)) {
      errors.push('Invalid phone number format');
    }

    if (!data.address.trim()) {
      errors.push('Address is required');
    }

    return errors;
  };

  export const validateHomeDetails = (data: HomeDetails): string[] => {
    const errors: string[] = [];
    const currentYear = new Date().getFullYear();

    if (data.yearBuilt < 1800 || data.yearBuilt > currentYear) {
      errors.push('Invalid year built');
    }

    if (data.homeSize < 100 || data.homeSize > 50000) {
      errors.push('Home size must be between 100 and 50,000 square feet');
    }

    if (data.numRooms < 1 || data.numRooms > 100) {
      errors.push('Number of rooms must be between 1 and 100');
    }

    if (data.numFloors < 1 || data.numFloors > 100) {
      errors.push('Number of floors must be between 1 and 100');
    }

    return errors;
  };

----- End of backend\src\types\energyAudit.ts -----



----- Start of backend\src\types\notifications.ts -----

// backend/src/types/notification.ts

/**
 * Represents a user's notification preferences
 */
export interface NotificationPreferences {
    email: boolean;
    inApp: boolean;
    push: boolean;
    frequency: NotificationFrequency;
    categories: NotificationCategory[];
    quiet_hours?: {
      start: string; // 24-hour format, e.g., "22:00"
      end: string;   // 24-hour format, e.g., "07:00"
      timezone: string;
    };
  }

  /**
   * Represents a notification entity
   */
  export interface Notification {
    id: string;
    userId: string;
    type: NotificationType;
    category: NotificationCategory;
    title: string;
    message: string;
    metadata?: Record<string, any>;
    priority: NotificationPriority;
    status: NotificationStatus;
    createdAt: Date;
    scheduledFor?: Date;
    deliveredAt?: Date;
    readAt?: Date;
    expiresAt?: Date;
    actions?: NotificationAction[];
  }

  /**
   * Notification delivery channel options
   */
  export type NotificationChannel = 'email' | 'inApp' | 'push';

  /**
   * Notification frequency settings
   */
  export type NotificationFrequency = 'instant' | 'daily' | 'weekly' | 'custom';

  /**
   * Priority levels for notifications
   */
  export type NotificationPriority = 'high' | 'medium' | 'low';

  /**
   * Status of a notification
   */
  export type NotificationStatus =
    | 'pending'    // Not yet delivered
    | 'scheduled'  // Scheduled for future delivery
    | 'delivered'  // Successfully delivered
    | 'read'       // Read by the user
    | 'failed'     // Delivery failed
    | 'expired'    // Past expiration date
    | 'cancelled'; // Cancelled before delivery

  /**
   * Categories of notifications
   */
  export type NotificationCategory =
    | 'account'          // Account-related notifications
    | 'audit'            // Energy audit notifications
    | 'recommendation'   // Product/energy saving recommendations
    | 'product'          // Product-related updates
    | 'achievement'      // Gamification achievements
    | 'savings'          // Energy savings milestones
    | 'reminder'         // General reminders
    | 'system'          // System notifications
    | 'promotion'        // Marketing/promotional notifications
    | 'community';       // Community-related notifications

  /**
   * Specific types of notifications
   */
  export type NotificationType =
    // Account notifications
    | 'account_created'
    | 'email_verified'
    | 'password_changed'
    | 'profile_updated'

    // Audit notifications
    | 'audit_started'
    | 'audit_completed'
    | 'audit_reminder'
    | 'audit_review_needed'

    // Recommendation notifications
    | 'new_recommendation'
    | 'recommendation_reminder'
    | 'savings_opportunity'
    | 'product_price_alert'

    // Achievement notifications
    | 'achievement_unlocked'
    | 'level_up'
    | 'milestone_reached'
    | 'savings_milestone'

    // System notifications
    | 'system_maintenance'
    | 'feature_update'
    | 'privacy_update'
    | 'security_alert'

    // Community notifications
    | 'community_milestone'
    | 'community_challenge'
    | 'community_update';

  /**
   * Actions that can be attached to a notification
   */
  export interface NotificationAction {
    id: string;
    label: string;
    type: NotificationActionType;
    url?: string;
    payload?: Record<string, any>;
    completedAt?: Date;
  }

  /**
   * Types of actions available for notifications
   */
  export type NotificationActionType =
    | 'link'           // Navigate to a URL
    | 'button'         // Trigger an action
    | 'form'           // Open a form
    | 'dismiss'        // Dismiss the notification
    | 'acknowledge';   // Acknowledge receipt

  /**
   * Template context for notification rendering
   */
  export interface NotificationTemplate {
    id: string;
    type: NotificationType;
    title: string;
    message: string;
    emailSubject?: string;
    emailTemplate?: string;
    pushTemplate?: string;
    category: NotificationCategory;
    defaultPriority: NotificationPriority;
    defaultActions?: NotificationAction[];
    metadata?: {
      requiredFields: string[];
      optionalFields: string[];
      placeholders: Record<string, string>;
    };
  }

  /**
   * Batch notification settings
   */
  export interface NotificationBatch {
    id: string;
    type: NotificationType;
    recipients: string[];  // User IDs
    template: NotificationTemplate;
    data: Record<string, any>;
    scheduledFor?: Date;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    createdAt: Date;
    completedAt?: Date;
    error?: string;
    metadata?: Record<string, any>;
  }

  /**
   * Notification delivery result
   */
  export interface NotificationDeliveryResult {
    success: boolean;
    channel: NotificationChannel;
    timestamp: Date;
    error?: string;
    metadata?: Record<string, any>;
  }

  /**
   * Notification analytics data
   */
  export interface NotificationAnalytics {
    totalSent: number;
    totalDelivered: number;
    totalRead: number;
    totalFailed: number;
    deliveryRate: number;
    readRate: number;
    averageReadTime: number;
    actionCompletionRate: number;
    byChannel: Record<NotificationChannel, number>;
    byType: Record<NotificationType, number>;
    byCategory: Record<NotificationCategory, number>;
  }

  /**
   * Error types for notification-related operations
   */
  export class NotificationError extends Error {
    constructor(
      message: string,
      public code: string,
      public details?: Record<string, any>
    ) {
      super(message);
      this.name = 'NotificationError';
    }
  }

  export class NotificationValidationError extends NotificationError {
    constructor(message: string, details?: Record<string, any>) {
      super(message, 'VALIDATION_ERROR', details);
      this.name = 'NotificationValidationError';
    }
  }

  export class NotificationDeliveryError extends NotificationError {
    constructor(message: string, details?: Record<string, any>) {
      super(message, 'DELIVERY_ERROR', details);
      this.name = 'NotificationDeliveryError';
    }
  }

----- End of backend\src\types\notifications.ts -----



----- Start of backend\src\types\product.ts -----

// src/types/product.ts
export interface Product {
  id: string;
  productUrl: string;
  mainCategory: string;
  subCategory: string;
  name: string;
  model: string;
  description: string;
  efficiency: string;
  features: string[];
  marketInfo: string;
  energyStarId: string;
  upcCodes?: string;
  additionalModels?: string;
  pdfUrl?: string;
  specifications: {
    [key: string]: string | number;
  };
}

export type ProductFilters = {
  mainCategory?: string;
  subCategory?: string;
  search?: string;
  efficiency?: string;
}

----- End of backend\src\types\product.ts -----



----- Start of backend\src\validators\homeAudit.validator.ts -----

// backend/src/validators/homeAudit.validator.ts

import { z } from 'zod';
import { appLogger } from '../config/logger';

// Basic info validation schema
const basicInfoSchema = z.object({
  fullName: z.string()
    .min(2, 'Full name must be at least 2 characters')
    .max(100, 'Full name must not exceed 100 characters'),
  email: z.string()
    .email('Invalid email format'),
  phone: z.string()
    .regex(/^\+?[\d\s-]{10,}$/, 'Invalid phone number format')
    .optional(),
  address: z.string()
    .min(5, 'Address must be at least 5 characters')
    .max(200, 'Address must not exceed 200 characters'),
  auditDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format')
});

// Home details validation schema
const homeDetailsSchema = z.object({
  yearBuilt: z.number()
    .int('Year must be a whole number')
    .min(1800, 'Year built must be after 1800')
    .max(new Date().getFullYear(), 'Year built cannot be in the future'),
  homeSize: z.number()
    .positive('Home size must be positive')
    .min(100, 'Home size must be at least 100 sq ft')
    .max(50000, 'Home size must not exceed 50,000 sq ft'),
  numRooms: z.number()
    .int('Number of rooms must be a whole number')
    .min(1, 'Must have at least 1 room')
    .max(100, 'Number of rooms must not exceed 100'),
  homeType: z.enum(['apartment', 'single-family', 'townhouse', 'duplex', 'other'], {
    errorMap: () => ({ message: 'Invalid home type selected' })
  }),
  numFloors: z.number()
    .int('Number of floors must be a whole number')
    .min(1, 'Must have at least 1 floor')
    .max(100, 'Number of floors must not exceed 100'),
  basementType: z.enum(['full', 'partial', 'crawlspace', 'slab', 'none', 'other'], {
    errorMap: () => ({ message: 'Invalid basement type selected' })
  }),
  basementHeating: z.enum(['heated', 'unheated', 'partial'])
    .optional()
});

// Current conditions validation schema
const insulationRatingSchema = z.enum(['poor', 'average', 'good', 'excellent', 'not-sure']);

const currentConditionsSchema = z.object({
  insulation: z.object({
    attic: insulationRatingSchema,
    walls: insulationRatingSchema,
    basement: insulationRatingSchema,
    floor: insulationRatingSchema
  }),
  windowType: z.enum(['single', 'double', 'triple', 'not-sure']),
  numWindows: z.number()
    .int('Number of windows must be a whole number')
    .min(0, 'Number of windows cannot be negative'),
  windowCondition: z.enum(['excellent', 'good', 'fair', 'poor']),
  weatherStripping: z.enum(['door-sweep', 'foam', 'metal', 'none', 'not-sure'])
});

// HVAC systems validation schema
const hvacSchema = z.object({
  heatingSystem: z.object({
    type: z.enum(['furnace', 'boiler', 'heat-pump', 'electric-baseboard', 'other']),
    fuelType: z.enum(['natural-gas', 'oil', 'electric', 'propane', 'other']),
    age: z.number()
      .int('System age must be a whole number')
      .min(0, 'System age cannot be negative')
      .max(100, 'System age seems too high'),
    lastService: z.string()
      .regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format')
  }),
  coolingSystem: z.object({
    type: z.enum(['central', 'window-unit', 'portable', 'none']),
    age: z.number()
      .int('System age must be a whole number')
      .min(0, 'System age cannot be negative')
      .max(100, 'System age seems too high')
  })
});

// Energy consumption validation schema
const energyConsumptionSchema = z.object({
  powerConsumption: z.string()
    .regex(/^\d+-\d+kW$/, 'Power consumption must be in format "X-YkW"'),
  occupancyHours: z.object({
    weekdays: z.enum(['0-6', '7-12', '13-18', '19-24']),
    weekends: z.enum(['0-6', '7-12', '13-18', '19-24'])
  }),
  season: z.enum([
    'mild-winter',
    'moderate-winter',
    'mild-summer',
    'moderate-summer',
    'peak-summer',
    'spring-fall'
  ]),
  occupancyPattern: z.string()
    .min(3, 'Occupancy pattern description required')
    .max(200, 'Occupancy pattern description too long'),
  monthlyBill: z.number()
    .positive('Monthly bill must be positive')
    .max(10000, 'Monthly bill seems unusually high'),
  peakUsageTimes: z.array(z.string())
    .min(1, 'At least one peak usage time required')
    .max(24, 'Too many peak usage times specified')
});

// Complete audit data validation schema
const energyAuditSchema = z.object({
  basicInfo: basicInfoSchema,
  homeDetails: homeDetailsSchema,
  currentConditions: currentConditionsSchema,
  heatingCooling: hvacSchema,
  energyConsumption: energyConsumptionSchema
});

// Validation function that returns typed results
export interface ValidationResult {
  success: boolean;
  errors?: z.ZodError;
  data?: z.infer<typeof energyAuditSchema>;
}

export const validateEnergyAudit = (data: unknown): ValidationResult => {
  try {
    const validatedData = energyAuditSchema.parse(data);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      appLogger.warn('Energy audit validation failed', {
        errors: error.errors
      });
      return {
        success: false,
        errors: error
      };
    }
    throw error;
  }
};

// Validation function for partial updates
export const validatePartialEnergyAudit = (data: unknown): ValidationResult => {
  try {
    const validatedData = energyAuditSchema.partial().parse(data);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      appLogger.warn('Partial energy audit validation failed', {
        errors: error.errors
      });
      return {
        success: false,
        errors: error
      };
    }
    throw error;
  }
};

// Individual section validators for step-by-step validation
export const validateBasicInfo = (data: unknown) => {
  return basicInfoSchema.safeParse(data);
};

export const validateHomeDetails = (data: unknown) => {
  return homeDetailsSchema.safeParse(data);
};

export const validateCurrentConditions = (data: unknown) => {
  return currentConditionsSchema.safeParse(data);
};

export const validateHVAC = (data: unknown) => {
  return hvacSchema.safeParse(data);
};

export const validateEnergyConsumption = (data: unknown) => {
  return energyConsumptionSchema.safeParse(data);
};

// Export types for use in other parts of the application
export type EnergyAuditType = z.infer<typeof energyAuditSchema>;
export type BasicInfoType = z.infer<typeof basicInfoSchema>;
export type HomeDetailsType = z.infer<typeof homeDetailsSchema>;
export type CurrentConditionsType = z.infer<typeof currentConditionsSchema>;
export type HVACType = z.infer<typeof hvacSchema>;
export type EnergyConsumptionType = z.infer<typeof energyConsumptionSchema>;

----- End of backend\src\validators\homeAudit.validator.ts -----



----- Start of backend\src\validators\product.validator.ts -----

// backend/src/validators/product.validator.ts

import { z } from 'zod';
import { appLogger } from '../config/logger';

// Regular expressions for validation
const URL_REGEX = /^https?:\/\/.+/;
const ENERGY_STAR_ID_REGEX = /^[A-Z0-9]{6,20}$/;
const MODEL_NUMBER_REGEX = /^[A-Za-z0-9-]+$/;
const UPC_CODE_REGEX = /^\d{12,14}$/;

// Product specification schema
const productSpecificationSchema = z.record(
  z.string(),
  z.union([z.string(), z.number()])
).refine((specs) => Object.keys(specs).length > 0, {
  message: 'At least one specification is required'
});

// Product features schema
const productFeaturesSchema = z.array(z.string()
  .min(3, 'Feature description must be at least 3 characters')
  .max(200, 'Feature description must not exceed 200 characters')
).min(1, 'At least one feature is required');

// Market information schema
const marketInfoSchema = z.object({
  price: z.number()
    .positive('Price must be positive')
    .optional(),
  availability: z.enum(['in-stock', 'out-of-stock', 'pre-order', 'discontinued'])
    .optional(),
  retailer: z.string()
    .min(2, 'Retailer name must be at least 2 characters')
    .optional(),
  region: z.string()
    .min(2, 'Region must be at least 2 characters')
    .optional(),
  warranty: z.object({
    duration: z.number().positive('Warranty duration must be positive'),
    unit: z.enum(['days', 'months', 'years']),
    description: z.string()
  }).optional()
});

// Main product validation schema
const productSchema = z.object({
  energyStarId: z.string()
    .regex(ENERGY_STAR_ID_REGEX, 'Invalid ENERGY STAR ID format')
    .optional(),

  name: z.string()
    .min(3, 'Product name must be at least 3 characters')
    .max(200, 'Product name must not exceed 200 characters'),

  mainCategory: z.string()
    .min(2, 'Main category must be at least 2 characters')
    .max(50, 'Main category must not exceed 50 characters'),

  subCategory: z.string()
    .min(2, 'Sub category must be at least 2 characters')
    .max(50, 'Sub category must not exceed 50 characters'),

  model: z.string()
    .regex(MODEL_NUMBER_REGEX, 'Invalid model number format'),

  description: z.string()
    .min(20, 'Description must be at least 20 characters')
    .max(2000, 'Description must not exceed 2000 characters'),

  efficiency: z.object({
    rating: z.string()
      .min(1, 'Efficiency rating is required'),
    value: z.number()
      .positive('Efficiency value must be positive'),
    unit: z.string()
      .min(1, 'Efficiency unit is required')
  }),

  features: productFeaturesSchema,

  specifications: productSpecificationSchema,

  marketInfo: marketInfoSchema,

  productUrl: z.string()
    .regex(URL_REGEX, 'Invalid product URL format'),

  pdfUrl: z.string()
    .regex(URL_REGEX, 'Invalid PDF URL format')
    .optional(),

  upcCodes: z.array(z.string()
    .regex(UPC_CODE_REGEX, 'Invalid UPC code format'))
    .min(1, 'At least one UPC code is required')
    .optional(),

  additionalModels: z.array(z.string()
    .regex(MODEL_NUMBER_REGEX, 'Invalid model number format'))
    .optional(),

  active: z.boolean()
    .default(true),

  metadata: z.record(z.string(), z.unknown())
    .optional()
});

// Product filter validation schema
const productFilterSchema = z.object({
  mainCategory: z.string().optional(),
  subCategory: z.string().optional(),
  search: z.string().optional(),
  efficiency: z.string().optional(),
  minPrice: z.number().positive().optional(),
  maxPrice: z.number().positive().optional(),
  sortBy: z.enum(['price', 'efficiency', 'name', 'relevance']).optional(),
  sortOrder: z.enum(['asc', 'desc']).optional(),
  page: z.number().int().positive().optional(),
  limit: z.number().int().positive().max(100).optional()
}).refine(
  (data) => !(data.minPrice && data.maxPrice && data.minPrice > data.maxPrice),
  {
    message: 'Minimum price cannot be greater than maximum price',
    path: ['minPrice']
  }
);

// Product batch operation schema
const productBatchSchema = z.object({
  products: z.array(productSchema)
    .min(1, 'At least one product is required')
    .max(1000, 'Batch size cannot exceed 1000 products'),
  operation: z.enum(['create', 'update', 'delete'])
});

// Validation function that returns typed results
export interface ValidationResult<T> {
  success: boolean;
  errors?: z.ZodError;
  data?: T;
}

export const validateProduct = (data: unknown): ValidationResult<z.infer<typeof productSchema>> => {
  try {
    const validatedData = productSchema.parse(data);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      appLogger.warn('Product validation failed', {
        errors: error.errors
      });
      return {
        success: false,
        errors: error
      };
    }
    throw error;
  }
};

export const validateProductFilter = (data: unknown): ValidationResult<z.infer<typeof productFilterSchema>> => {
  try {
    const validatedData = productFilterSchema.parse(data);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      appLogger.warn('Product filter validation failed', {
        errors: error.errors
      });
      return {
        success: false,
        errors: error
      };
    }
    throw error;
  }
};

export const validateProductBatch = (data: unknown): ValidationResult<z.infer<typeof productBatchSchema>> => {
  try {
    const validatedData = productBatchSchema.parse(data);
    return {
      success: true,
      data: validatedData
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      appLogger.warn('Product batch validation failed', {
        errors: error.errors
      });
      return {
        success: false,
        errors: error
      };
    }
    throw error;
  }
};

// Export types for use in other parts of the application
export type ProductType = z.infer<typeof productSchema>;
export type ProductFilterType = z.infer<typeof productFilterSchema>;
export type ProductBatchType = z.infer<typeof productBatchSchema>;
export type ProductSpecificationType = z.infer<typeof productSpecificationSchema>;
export type MarketInfoType = z.infer<typeof marketInfoSchema>;

----- End of backend\src\validators\product.validator.ts -----



----- Start of src\App.css -----

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


----- End of src\App.css -----



----- Start of src\App.tsx -----

import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Header from './components/layout/Header';
import Footer from './components/layout/Footer';
import ProductsPage from './pages/ProductsPage';
import ProductDetailPage from './pages/ProductDetailPage';
import EnergyAuditPage from './pages/EnergyAuditPage';
import EducationPage from './pages/EducationPage';
import { Alert, AlertDescription, AlertTitle } from './components/ui/alert';
import { LineChart, Battery, Users } from 'lucide-react';


// Home component with all the landing page content
const Home: React.FC = () => {
  const features = [
    {
      title: 'Product Catalog',
      description: 'Browse our selection of energy-efficient products with detailed specifications and reviews.',
      icon: <LineChart className="h-6 w-6 text-green-600" />
    },
    {
      title: 'DIY Energy Audit',
      description: 'Get a personalized energy efficiency report and recommendations for your home.',
      icon: <Battery className="h-6 w-6 text-green-600" />
    },
    {
      title: 'Community',
      description: 'Connect with other homeowners and share experiences about energy-saving initiatives.',
      icon: <Users className="h-6 w-6 text-green-600" />
    }
  ];

  const stats = [
    { stat: '30%', label: 'Average Energy Savings' },
    { stat: '50k+', label: 'Products Available' },
    { stat: '10k+', label: 'Happy Customers' }
  ];

  return (
    <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
      {/* Hero Section */}
      <Alert className="mb-8">
        <AlertTitle className="text-lg font-semibold">Welcome to Energy Efficient Store!</AlertTitle>
        <AlertDescription>
          Your one-stop shop for energy-efficient products. Start with a DIY energy audit to get personalized recommendations.
        </AlertDescription>
      </Alert>

      {/* Feature Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12">
        {features.map((feature) => (
          <div
            key={feature.title}
            className="bg-white overflow-hidden shadow-sm rounded-lg hover:shadow-md transition-shadow duration-200"
          >
            <div className="p-6">
              <div className="mb-4">{feature.icon}</div>
              <h3 className="text-lg font-medium text-gray-900 mb-2">{feature.title}</h3>
              <p className="text-sm text-gray-500">{feature.description}</p>
              <button className="mt-4 text-green-600 hover:text-green-700 text-sm font-medium">
                Learn more →
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Energy Savings Stats */}
      <div className="bg-green-50 rounded-lg p-8 mb-12">
        <h2 className="text-2xl font-semibold text-gray-900 mb-6 text-center">
          Make an Impact with Energy Efficiency
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          {stats.map((item) => (
            <div key={item.label} className="text-center">
              <p className="text-4xl font-bold text-green-600 mb-2">{item.stat}</p>
              <p className="text-sm text-gray-600">{item.label}</p>
            </div>
          ))}
        </div>
      </div>

      {/* CTA Section */}
      <div className="bg-green-600 rounded-lg p-8 text-center">
        <h2 className="text-2xl font-bold text-white mb-4">
          Ready to Start Saving?
        </h2>
        <p className="text-green-100 mb-6 max-w-2xl mx-auto">
          Take our DIY energy audit today and discover personalized recommendations for your home's energy efficiency.
        </p>
        <button className="bg-white text-green-600 px-6 py-3 rounded-lg font-medium hover:bg-green-50 transition-colors duration-200">
          Start Energy Audit
        </button>
      </div>
    </div>
  );
};

// Main App component with routing
const App: React.FC = () => {
  return (
    <Router>
      <div className="min-h-screen flex flex-col bg-gray-50">
        <Header />
        <main className="flex-grow">
          <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/products" element={<ProductsPage />} />
            <Route path="/products/:id" element={<ProductDetailPage />} />
            <Route path="/energy-audit" element={<EnergyAuditPage />} />
            <Route path="/education" element={<EducationPage />} />
            {/* Add more routes as needed:
            <Route path="/community" element={<CommunityPage />} />
            */}
          </Routes>
        </main>
        <Footer />
      </div>
    </Router>
  );
};

export default App;

----- End of src\App.tsx -----



----- Start of src\file_tree.txt -----

📦energy-audit-store
 ┣ 📂public
 ┃ ┣ 📂data
 ┃ ┃ ┗ 📜products.csv
 ┃ ┗ 📜vite.svg
 ┣ 📂src
 ┃ ┣ 📂assets
 ┃ ┃ ┗ 📜react.svg
 ┃ ┣ 📂components
 ┃ ┃ ┣ 📂audit
 ┃ ┃ ┃ ┗ 📜EnergyAuditForm.tsx
 ┃ ┃ ┣ 📂layout
 ┃ ┃ ┃ ┣ 📜Footer.tsx
 ┃ ┃ ┃ ┗ 📜Header.tsx
 ┃ ┃ ┣ 📂products
 ┃ ┃ ┃ ┣ 📜EnergySavingsCard.tsx
 ┃ ┃ ┃ ┣ 📜ProductDetailHeader.tsx
 ┃ ┃ ┃ ┗ 📜ProductSpecifications.tsx
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┣ 📜alert.tsx
 ┃ ┃ ┃ ┗ 📜badge.tsx
 ┃ ┣ 📂config
 ┃ ┃ ┗ 📜database.ts
 ┃ ┣ 📂hooks
 ┃ ┃ ┗ 📜useProducts.ts
 ┃ ┣ 📂lib
 ┃ ┃ ┗ 📜utils.ts
 ┃ ┣ 📂middleware
 ┃ ┃ ┗ 📜auth.ts
 ┃ ┣ 📂pages
 ┃ ┃ ┣ 📜EducationPage.tsx
 ┃ ┃ ┣ 📜EnergyAuditPage.tsx
 ┃ ┃ ┣ 📜ProductDetailPage.tsx
 ┃ ┃ ┗ 📜ProductsPage.tsx
 ┃ ┣ 📂routes
 ┃ ┃ ┣ 📜auth.ts
 ┃ ┃ ┗ 📜emailVerification.ts
 ┃ ┣ 📂services
 ┃ ┃ ┣ 📜EnergyAuditService.ts
 ┃ ┃ ┣ 📜productDataService.ts
 ┃ ┃ ┣ 📜productService.ts
 ┃ ┃ ┗ 📜userAuthService.ts
 ┃ ┣ 📂types
 ┃ ┃ ┣ 📜energyAudit.ts
 ┃ ┃ ┗ 📜product.ts
 ┃ ┣ 📜App.css
 ┃ ┣ 📜app.ts
 ┃ ┣ 📜App.tsx
 ┃ ┣ 📜index.css
 ┃ ┣ 📜main.tsx
 ┃ ┗ 📜vite-env.d.ts
 ┣ 📜.env
 ┣ 📜.gitignore
 ┣ 📜database_setup.sql
 ┣ 📜eslint.config.js
 ┣ 📜index.html
 ┣ 📜package-lock.json
 ┣ 📜package.json
 ┣ 📜postcss.config.js
 ┣ 📜README.md
 ┣ 📜tailwind.config.js
 ┣ 📜tsconfig.app.json
 ┣ 📜tsconfig.json
 ┣ 📜tsconfig.node.json
 ┗ 📜vite.config.ts

----- End of src\file_tree.txt -----



----- Start of src\index.css -----

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
}

body {
  margin: 0;
  min-height: 100vh;
}


----- End of src\index.css -----



----- Start of src\main.tsx -----

import React from 'react'
import { createRoot } from 'react-dom/client'
import App from './App'
import './index.css'

const container = document.getElementById('root')
if (!container) {
  throw new Error('Failed to find the root element')
}

const root = createRoot(container)
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

----- End of src\main.tsx -----



----- Start of src\vite-env.d.ts -----

/// <reference types="vite/client" />


----- End of src\vite-env.d.ts -----



----- Start of src\components\audit\EnergyAuditForm.tsx -----

// src/components/audit/EnergyAuditForm.tsx

import React, { useState } from 'react';
import {
  ArrowLeft,
  ArrowRight,
  Home,
  Thermometer,
  Lightbulb,
  Sun,
  DollarSign,
  BadgeCheck
} from 'lucide-react';

// Form section configuration
const FORM_SECTIONS = {
  BASIC_INFO: {
    id: 'basicInfo',
    title: 'Basic Information',
    icon: <Home className="h-6 w-6 text-green-600" />
  },
  HOME_DETAILS: {
    id: 'homeDetails',
    title: 'Home Details',
    icon: <Home className="h-6 w-6 text-green-600" />
  },
  CURRENT_CONDITIONS: {
    id: 'currentConditions',
    title: 'Current Conditions',
    icon: <Thermometer className="h-6 w-6 text-green-600" />
  },
  HVAC: {
    id: 'hvac',
    title: 'HVAC Systems',
    icon: <Thermometer className="h-6 w-6 text-green-600" />
  }
};

const EnergyAuditForm = () => {
  const [currentSection, setCurrentSection] = useState(FORM_SECTIONS.BASIC_INFO.id);
  const [formData, setFormData] = useState({
    basicInfo: {
      fullName: '',
      email: '',
      phone: '',
      address: '',
      auditDate: new Date().toISOString().split('T')[0]
    },
    homeDetails: {
      yearBuilt: '',
      homeSize: '',
      numRooms: '',
      homeType: '',
      numFloors: '',
      basementType: ''
    },
    currentConditions: {
      temperatureConsistency: '',
      windowCount: '',
      comfortIssues: []
    },
    hvac: {
      heatingType: '',
      coolingType: '',
      systemAge: '',
      lastService: ''
    }
  });

  const handleInputChange = (section, field, value) => {
    setFormData(prev => ({
      ...prev,
      [section]: {
        ...prev[section],
        [field]: value
      }
    }));
  };

  const handleMultiSelect = (section, field, value) => {
    setFormData(prev => ({
      ...prev,
      [section]: {
        ...prev[section],
        [field]: prev[section][field].includes(value)
          ? prev[section][field].filter(item => item !== value)
          : [...prev[section][field], value]
      }
    }));
  };

  const renderProgressBar = () => {
    const sections = Object.values(FORM_SECTIONS);
    const currentIndex = sections.findIndex(section => section.id === currentSection);
    const progress = ((currentIndex + 1) / sections.length) * 100;

    return (
      <div className="w-full bg-gray-200 rounded-full h-2 mb-6">
        <div
          className="bg-green-600 h-2 rounded-full transition-all duration-300"
          style={{ width: `${progress}%` }}
        />
      </div>
    );
  };

  const renderBasicInfoSection = () => (
    <div className="space-y-6">
      <h3 className="text-lg font-semibold text-gray-900">Basic Information</h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Full Name *</label>
          <input
            type="text"
            required
            className="w-full p-2 border rounded-md"
            value={formData.basicInfo.fullName}
            onChange={(e) => handleInputChange('basicInfo', 'fullName', e.target.value)}
          />
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Email *</label>
          <input
            type="email"
            required
            className="w-full p-2 border rounded-md"
            value={formData.basicInfo.email}
            onChange={(e) => handleInputChange('basicInfo', 'email', e.target.value)}
          />
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Phone</label>
          <input
            type="tel"
            className="w-full p-2 border rounded-md"
            value={formData.basicInfo.phone}
            onChange={(e) => handleInputChange('basicInfo', 'phone', e.target.value)}
          />
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Address *</label>
          <input
            type="text"
            required
            className="w-full p-2 border rounded-md"
            value={formData.basicInfo.address}
            onChange={(e) => handleInputChange('basicInfo', 'address', e.target.value)}
          />
        </div>
      </div>
    </div>
  );

  const renderHomeDetailsSection = () => (
    <div className="space-y-6">
      <h3 className="text-lg font-semibold text-gray-900">Home Details</h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Year Built *</label>
          <input
            type="number"
            required
            min="1800"
            max={new Date().getFullYear()}
            className="w-full p-2 border rounded-md"
            value={formData.homeDetails.yearBuilt}
            onChange={(e) => handleInputChange('homeDetails', 'yearBuilt', e.target.value)}
          />
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Home Type *</label>
          <select
            required
            className="w-full p-2 border rounded-md"
            value={formData.homeDetails.homeType}
            onChange={(e) => handleInputChange('homeDetails', 'homeType', e.target.value)}
          >
            <option value="">Select home type</option>
            <option value="single-family">Single-family detached</option>
            <option value="townhouse">Townhouse/Rowhome</option>
            <option value="duplex">Duplex/Condo</option>
            <option value="mobile">Mobile home</option>
          </select>
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Square Footage *</label>
          <input
            type="number"
            required
            min="100"
            className="w-full p-2 border rounded-md"
            value={formData.homeDetails.homeSize}
            onChange={(e) => handleInputChange('homeDetails', 'homeSize', e.target.value)}
          />
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Number of Floors *</label>
          <input
            type="number"
            required
            min="1"
            className="w-full p-2 border rounded-md"
            value={formData.homeDetails.numFloors}
            onChange={(e) => handleInputChange('homeDetails', 'numFloors', e.target.value)}
          />
        </div>
      </div>
    </div>
  );

  const renderCurrentConditionsSection = () => (
    <div className="space-y-6">
      <h3 className="text-lg font-semibold text-gray-900">Current Conditions</h3>
      <div className="space-y-4">
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Temperature Consistency</label>
          <select
            className="w-full p-2 border rounded-md"
            value={formData.currentConditions.temperatureConsistency}
            onChange={(e) => handleInputChange('currentConditions', 'temperatureConsistency', e.target.value)}
          >
            <option value="">Select consistency level</option>
            <option value="very-consistent">Very consistent throughout home</option>
            <option value="some-variation">Some noticeable variations</option>
            <option value="large-variation">Large variations between areas</option>
          </select>
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Window Assessment</label>
          <select
            className="w-full p-2 border rounded-md"
            value={formData.currentConditions.windowCount}
            onChange={(e) => handleInputChange('currentConditions', 'windowCount', e.target.value)}
          >
            <option value="">Select window count</option>
            <option value="few">Few windows (less than 10)</option>
            <option value="average">Average number (10-20)</option>
            <option value="many">Many windows (more than 20)</option>
          </select>
        </div>
      </div>
    </div>
  );

  const renderHVACSection = () => (
    <div className="space-y-6">
      <h3 className="text-lg font-semibold text-gray-900">HVAC Systems</h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Heating System Type</label>
          <select
            className="w-full p-2 border rounded-md"
            value={formData.hvac.heatingType}
            onChange={(e) => handleInputChange('hvac', 'heatingType', e.target.value)}
          >
            <option value="">Select heating type</option>
            <option value="furnace">Forced air (vents in floors/walls)</option>
            <option value="radiator">Radiators or baseboards</option>
            <option value="heat-pump">Heat pump</option>
            <option value="portable">Portable heaters</option>
          </select>
        </div>
        <div className="space-y-2">
          <label className="text-sm font-medium text-gray-700">Cooling System Type</label>
          <select
            className="w-full p-2 border rounded-md"
            value={formData.hvac.coolingType}
            onChange={(e) => handleInputChange('hvac', 'coolingType', e.target.value)}
          >
            <option value="">Select cooling type</option>
            <option value="central">Central air conditioning</option>
            <option value="window">Window units</option>
            <option value="portable">Portable units</option>
            <option value="none">None</option>
          </select>
        </div>
      </div>
    </div>
  );

  const renderCurrentSection = () => {
    switch (currentSection) {
      case FORM_SECTIONS.BASIC_INFO.id:
        return renderBasicInfoSection();
      case FORM_SECTIONS.HOME_DETAILS.id:
        return renderHomeDetailsSection();
      case FORM_SECTIONS.CURRENT_CONDITIONS.id:
        return renderCurrentConditionsSection();
      case FORM_SECTIONS.HVAC.id:
        return renderHVACSection();
      default:
        return null;
    }
  };

  const sections = Object.values(FORM_SECTIONS);
  const currentIndex = sections.findIndex(section => section.id === currentSection);

  const handleNext = () => {
    if (currentIndex < sections.length - 1) {
      setCurrentSection(sections[currentIndex + 1].id);
    }
  };

  const handlePrevious = () => {
    if (currentIndex > 0) {
      setCurrentSection(sections[currentIndex - 1].id);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // TODO: Implement form submission
    console.log('Form data:', formData);
  };

  return (
    <form onSubmit={handleSubmit} className="max-w-4xl mx-auto px-4 py-8">
      <div className="mb-8">
        <h2 className="text-2xl font-bold text-gray-900">DIY Energy Audit</h2>
        <p className="mt-2 text-gray-600">
          Complete this form to receive personalized energy efficiency recommendations.
        </p>
      </div>

      {renderProgressBar()}

      <div className="bg-white rounded-lg shadow-sm p-6">
        {renderCurrentSection()}

        <div className="flex justify-between mt-8">
          <button
            type="button"
            onClick={handlePrevious}
            disabled={currentIndex === 0}
            className="flex items-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50"
          >
            <ArrowLeft className="w-4 h-4 mr-2" />
            Previous
          </button>

          {currentIndex === sections.length - 1 ? (
            <button
              type="submit"
              className="flex items-center px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700"
            >
              Submit
              <BadgeCheck className="w-4 h-4 ml-2" />
            </button>
          ) : (
            <button
              type="button"
              onClick={handleNext}
              className="flex items-center px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700"
            >
              Next
              <ArrowRight className="w-4 h-4 ml-2" />
            </button>
          )}
        </div>
      </div>
    </form>
  );
};

export default EnergyAuditForm;

----- End of src\components\audit\EnergyAuditForm.tsx -----



----- Start of src\components\auth\AuthService.ts -----

import { Pool } from 'pg';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { emailService } from './emailService';

const SALT_ROUNDS = 12;
const JWT_SECRET = process.env.JWT_SECRET || '';
const TOKEN_EXPIRY = '24h';

export class AuthService {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  async signup({ email, password, fullName, phone, address }: SignupData): Promise<AuthResult> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // Check for existing user
      const existingUser = await client.query(
        'SELECT id FROM users WHERE email = $1',
        [email]
      );

      if (existingUser.rows.length > 0) {
        throw new AuthError('Email already registered');
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);

      // Create verification token
      const verificationToken = crypto.randomBytes(32).toString('hex');
      const tokenExpiry = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

      // Insert user
      const result = await client.query(
        `INSERT INTO users (
          email, password_hash, full_name, phone, address,
          verification_token, verification_expires
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, email, full_name, created_at`,
        [email, hashedPassword, fullName, phone, address, verificationToken, tokenExpiry]
      );

      await client.query('COMMIT');

      // Send verification email
      await emailService.sendVerificationEmail(
        email,
        verificationToken,
        fullName
      );

      // Generate auth token
      const token = this.generateToken(result.rows[0]);

      return {
        user: {
          id: result.rows[0].id,
          email: result.rows[0].email,
          fullName: result.rows[0].full_name
        },
        token
      };

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async signin({ email, password }: SigninData): Promise<AuthResult> {
    const result = await this.pool.query(
      `SELECT * FROM users
       WHERE email = $1 AND verified = true`,
      [email]
    );

    if (result.rows.length === 0) {
      throw new AuthError('Invalid email or password');
    }

    const user = result.rows[0];

    const validPassword = await bcrypt.compare(password, user.password_hash);
    if (!validPassword) {
      throw new AuthError('Invalid email or password');
    }

    // Update last login
    await this.pool.query(
      'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1',
      [user.id]
    );

    const token = this.generateToken(user);

    return {
      user: {
        id: user.id,
        email: user.email,
        fullName: user.full_name
      },
      token
    };
  }

  async verifyEmail(token: string): Promise<void> {
    const result = await this.pool.query(
      `UPDATE users
       SET verified = true,
           verification_token = NULL,
           verification_expires = NULL
       WHERE verification_token = $1
       AND verification_expires > CURRENT_TIMESTAMP
       RETURNING id`,
      [token]
    );

    if (result.rowCount === 0) {
      throw new AuthError('Invalid or expired verification token');
    }
  }

  async resetPasswordRequest(email: string): Promise<void> {
    const result = await this.pool.query(
      'SELECT id, full_name FROM users WHERE email = $1',
      [email]
    );

    if (result.rows.length === 0) {
      return; // Don't reveal if email exists
    }

    const resetToken = crypto.randomBytes(32).toString('hex');
    const tokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    await this.pool.query(
      `UPDATE users
       SET reset_token = $1,
           reset_expires = $2
       WHERE email = $3`,
      [resetToken, tokenExpiry, email]
    );

    await emailService.sendPasswordResetEmail(email, resetToken);
  }

  async resetPassword(token: string, newPassword: string): Promise<void> {
    const hashedPassword = await bcrypt.hash(newPassword, SALT_ROUNDS);

    const result = await this.pool.query(
      `UPDATE users
       SET password_hash = $1,
           reset_token = NULL,
           reset_expires = NULL
       WHERE reset_token = $2
       AND reset_expires > CURRENT_TIMESTAMP
       RETURNING id`,
      [hashedPassword, token]
    );

    if (result.rowCount === 0) {
      throw new AuthError('Invalid or expired reset token');
    }
  }

  async getUserSettings(userId: string): Promise<UserSettings> {
    const result = await this.pool.query(
      `SELECT full_name, email, phone, address
       FROM users WHERE id = $1`,
      [userId]
    );

    if (result.rows.length === 0) {
      throw new AuthError('User not found');
    }

    return result.rows[0];
  }

  async updateUserSettings(userId: string, settings: Partial<UserSettings>): Promise<UserSettings> {
    const allowedFields = ['full_name', 'phone', 'address'];
    const updates = [];
    const values = [];
    let paramCount = 1;

    for (const [key, value] of Object.entries(settings)) {
      if (allowedFields.includes(key)) {
        updates.push(`${key} = $${paramCount}`);
        values.push(value);
        paramCount++;
      }
    }

    if (updates.length === 0) {
      throw new AuthError('No valid fields to update');
    }

    values.push(userId);

    const result = await this.pool.query(
      `UPDATE users
       SET ${updates.join(', ')},
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $${paramCount}
       RETURNING full_name, email, phone, address`,
      values
    );

    return result.rows[0];
  }

  verifyToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, JWT_SECRET) as JWTPayload;
    } catch (error) {
      throw new AuthError('Invalid token');
    }
  }

  private generateToken(user: UserData): string {
    return jwt.sign(
      {
        userId: user.id,
        email: user.email
      },
      JWT_SECRET,
      { expiresIn: TOKEN_EXPIRY }
    );
  }
}

// Types
interface SignupData {
  email: string;
  password: string;
  fullName: string;
  phone?: string;
  address?: string;
}

interface SigninData {
  email: string;
  password: string;
}

interface AuthResult {
  user: {
    id: string;
    email: string;
    fullName: string;
  };
  token: string;
}

interface UserSettings {
  fullName: string;
  email: string;
  phone?: string;
  address?: string;
}

interface JWTPayload {
  userId: string;
  email: string;
  iat: number;
  exp: number;
}

interface UserData {
  id: string;
  email: string;
  full_name: string;
}

// Error handling
export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

----- End of src\components\auth\AuthService.ts -----



----- Start of src\components\auth\SignIn.tsx -----

// src/components/auth/SignIn.tsx

import React, { useState, useEffect } from 'react';
import { Alert, AlertDescription } from '@/components/ui/alert';

const SignIn = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    rememberMe: false
  });
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // Check for saved email in localStorage
  useEffect(() => {
    const savedEmail = localStorage.getItem('savedEmail');
    if (savedEmail) {
      setFormData(prev => ({
        ...prev,
        email: savedEmail
      }));
    }
  }, []);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const validateForm = () => {
    if (!formData.email) {
      setError('Email is required');
      return false;
    }
    if (!formData.email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
      setError('Invalid email format');
      return false;
    }
    if (!formData.password) {
      setError('Password is required');
      return false;
    }
    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');

    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      const response = await fetch('/api/auth/signin', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: formData.email,
          password: formData.password,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Sign in failed');
      }

      // Handle successful sign in
      if (formData.rememberMe) {
        localStorage.setItem('savedEmail', formData.email);
      } else {
        localStorage.removeItem('savedEmail');
      }

      // Redirect to dashboard or home page
      window.location.href = '/dashboard';

    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen bg-gray-50">
      <div className="w-full max-w-md mx-auto my-12">
        <div className="bg-white p-8 rounded-lg shadow-sm">
          <h2 className="text-2xl font-bold text-gray-900 mb-6">Sign In</h2>

          {error && (
            <Alert variant="destructive" className="mb-6">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700"
              >
                Email
              </label>
              <input
                id="email"
                name="email"
                type="email"
                required
                className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                value={formData.email}
                onChange={handleInputChange}
              />
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700"
              >
                Password
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                value={formData.password}
                onChange={handleInputChange}
              />
            </div>

            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <input
                  id="rememberMe"
                  name="rememberMe"
                  type="checkbox"
                  className="h-4 w-4 text-green-600 focus:ring-green-500 border-gray-300 rounded"
                  checked={formData.rememberMe}
                  onChange={handleInputChange}
                />
                <label
                  htmlFor="rememberMe"
                  className="ml-2 block text-sm text-gray-900"
                >
                  Remember me
                </label>
              </div>

              <div className="text-sm">
                <a
                  href="/forgot-password"
                  className="font-medium text-green-600 hover:text-green-500"
                >
                  Forgot your password?
                </a>
              </div>
            </div>

            <div>
              <button
                type="submit"
                disabled={isLoading}
                className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isLoading ? 'Signing in...' : 'Sign in'}
              </button>
            </div>
          </form>

          <div className="mt-6">
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-gray-300" />
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="px-2 bg-white text-gray-500">
                  New to our platform?
                </span>
              </div>
            </div>

            <div className="mt-6">
              <a
                href="/signup"
                className="w-full flex justify-center py-2 px-4 border border-green-600 rounded-md shadow-sm text-sm font-medium text-green-600 bg-white hover:bg-green-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
              >
                Create an account
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SignIn;

----- End of src\components\auth\SignIn.tsx -----



----- Start of src\components\auth\SignUp.tsx -----

// src/components/auth/SignUp.tsx

import React, { useState, useEffect } from 'react';
import { Alert, AlertDescription } from '@/components/ui/alert';

const SignUp = () => {
  const [formData, setFormData] = useState({
    fullName: '',
    email: '',
    password: '',
    confirmPassword: '',
    phone: '',
    address: '',
    termsAccepted: false
  });

  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [step, setStep] = useState(1);

  // Load saved form data from localStorage
  useEffect(() => {
    const savedData = localStorage.getItem('signupFormData');
    if (savedData) {
      const parsedData = JSON.parse(savedData);
      setFormData(prev => ({
        ...prev,
        ...parsedData
      }));
    }
  }, []);

  // Save form progress
  useEffect(() => {
    const dataToSave = { ...formData };
    delete dataToSave.password;
    delete dataToSave.confirmPassword;
    localStorage.setItem('signupFormData', JSON.stringify(dataToSave));
  }, [formData]);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const validateForm = () => {
    if (step === 1) {
      if (!formData.fullName || formData.fullName.length < 2) {
        setError('Full name is required and must be at least 2 characters');
        return false;
      }
      if (!formData.email?.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
        setError('Valid email is required');
        return false;
      }
      if (formData.password.length < 8) {
        setError('Password must be at least 8 characters');
        return false;
      }
      if (formData.password !== formData.confirmPassword) {
        setError('Passwords do not match');
        return false;
      }
    }

    if (step === 2) {
      if (formData.phone && !formData.phone.match(/^\+?[\d\s-]+$/)) {
        setError('Invalid phone format');
        return false;
      }
      if (!formData.termsAccepted) {
        setError('You must accept the terms and conditions');
        return false;
      }
    }

    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');

    if (!validateForm()) {
      return;
    }

    if (step === 1) {
      setStep(2);
      return;
    }

    setIsLoading(true);

    try {
      const response = await fetch('/api/auth/signup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          fullName: formData.fullName,
          email: formData.email,
          password: formData.password,
          phone: formData.phone,
          address: formData.address
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Registration failed');
      }

      // Clear saved form data
      localStorage.removeItem('signupFormData');

      // Redirect to verification page
      window.location.href = '/verify-email';

    } catch (err) {
      setError(err.message);
      setIsLoading(false);
    }
  };

  const renderStep1 = () => (
    <>
      <div className="space-y-4">
        <div>
          <label htmlFor="fullName" className="block text-sm font-medium text-gray-700">
            Full Name
          </label>
          <input
            id="fullName"
            name="fullName"
            type="text"
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
            value={formData.fullName}
            onChange={handleInputChange}
          />
        </div>

        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            Email
          </label>
          <input
            id="email"
            name="email"
            type="email"
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
            value={formData.email}
            onChange={handleInputChange}
          />
        </div>

        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            Password
          </label>
          <input
            id="password"
            name="password"
            type="password"
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
            value={formData.password}
            onChange={handleInputChange}
          />
        </div>

        <div>
          <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
            Confirm Password
          </label>
          <input
            id="confirmPassword"
            name="confirmPassword"
            type="password"
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
            value={formData.confirmPassword}
            onChange={handleInputChange}
          />
        </div>
      </div>
    </>
  );

  const renderStep2 = () => (
    <>
      <div className="space-y-4">
        <div>
          <label htmlFor="phone" className="block text-sm font-medium text-gray-700">
            Phone (optional)
          </label>
          <input
            id="phone"
            name="phone"
            type="tel"
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
            value={formData.phone}
            onChange={handleInputChange}
          />
        </div>

        <div>
          <label htmlFor="address" className="block text-sm font-medium text-gray-700">
            Address (optional)
          </label>
          <textarea
            id="address"
            name="address"
            rows={3}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
            value={formData.address}
            onChange={handleInputChange}
          />
        </div>

        <div className="flex items-center">
          <input
            id="termsAccepted"
            name="termsAccepted"
            type="checkbox"
            className="h-4 w-4 text-green-600 focus:ring-green-500 border-gray-300 rounded"
            checked={formData.termsAccepted}
            onChange={handleInputChange}
          />
          <label htmlFor="termsAccepted" className="ml-2 block text-sm text-gray-900">
            I accept the <a href="/terms" className="text-green-600 hover:text-green-500">terms and conditions</a>
          </label>
        </div>
      </div>
    </>
  );

  return (
    <div className="flex min-h-screen bg-gray-50">
      <div className="w-full max-w-md mx-auto my-12">
        <div className="bg-white p-8 rounded-lg shadow-sm">
          <h2 className="text-2xl font-bold text-gray-900 mb-6">Create Account</h2>

          {/* Progress indicator */}
          <div className="mb-8">
            <div className="flex justify-between">
              <span className={`text-sm ${step >= 1 ? 'text-green-600' : 'text-gray-500'}`}>
                Basic Info
              </span>
              <span className={`text-sm ${step >= 2 ? 'text-green-600' : 'text-gray-500'}`}>
                Additional Details
              </span>
            </div>
            <div className="mt-2 h-2 bg-gray-200 rounded-full">
              <div
                className="h-2 bg-green-600 rounded-full transition-all duration-300"
                style={{ width: `${(step / 2) * 100}%` }}
              />
            </div>
          </div>

          {error && (
            <Alert variant="destructive" className="mb-6">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            {step === 1 ? renderStep1() : renderStep2()}

            <div className="flex justify-between">
              {step === 2 && (
                <button
                  type="button"
                  onClick={() => setStep(1)}
                  className="px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-900"
                >
                  Back
                </button>
              )}
              <button
                type="submit"
                disabled={isLoading}
                className="flex-1 ml-3 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isLoading ? 'Creating account...' : step === 1 ? 'Next' : 'Create Account'}
              </button>
            </div>
          </form>

          <div className="mt-6 text-center">
            <span className="text-sm text-gray-600">
              Already have an account?{' '}
              <a href="/signin" className="text-green-600 hover:text-green-500 font-medium">
                Sign in
              </a>
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SignUp;

----- End of src\components\auth\SignUp.tsx -----



----- Start of src\components\layout\Footer.tsx -----

// src/components/layout/Footer.tsx

import React from 'react';

const Footer: React.FC = () => {
  return (
    <footer className="bg-white border-t">
      <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:px-8">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
          {/* Company Info */}
          <div className="space-y-4">
            <h3 className="text-lg font-semibold text-gray-900">Energy Efficient Store</h3>
            <p className="text-sm text-gray-600">
              Making energy efficiency accessible and affordable for everyone.
            </p>
          </div>

          {/* Quick Links */}
          <div>
            <h3 className="text-sm font-semibold text-gray-900 tracking-wider uppercase">Quick Links</h3>
            <ul className="mt-4 space-y-2">
              {['Products', 'Energy Audit', 'Community', 'About Us'].map((item) => (
                <li key={item}>
                  <a href="#" className="text-sm text-gray-600 hover:text-gray-900">
                    {item}
                  </a>
                </li>
              ))}
            </ul>
          </div>

          {/* Resources */}
          <div>
            <h3 className="text-sm font-semibold text-gray-900 tracking-wider uppercase">Resources</h3>
            <ul className="mt-4 space-y-2">
              {['Blog', 'Guides', 'FAQ', 'Support'].map((item) => (
                <li key={item}>
                  <a href="#" className="text-sm text-gray-600 hover:text-gray-900">
                    {item}
                  </a>
                </li>
              ))}
            </ul>
          </div>

          {/* Contact */}
          <div>
            <h3 className="text-sm font-semibold text-gray-900 tracking-wider uppercase">Contact</h3>
            <ul className="mt-4 space-y-2">
              <li>
                <a href="mailto:support@ees.com" className="text-sm text-gray-600 hover:text-gray-900">
                  support@ees.com
                </a>
              </li>
              <li className="text-sm text-gray-600">
                1234 Green Street
                <br />
                Eco City, EC 12345
              </li>
            </ul>
          </div>
        </div>

        <div className="mt-8 pt-8 border-t border-gray-200">
          <p className="text-sm text-gray-400 text-center">
            © {new Date().getFullYear()} Energy Efficient Store. All rights reserved.
          </p>
        </div>
      </div>
    </footer>
  );
};

export default Footer;

----- End of src\components\layout\Footer.tsx -----



----- Start of src\components\layout\Header.tsx -----

// src/components/layout/Header.tsx

import React from 'react';
import { Menu } from 'lucide-react';

const Header: React.FC = () => {
  return (
    <header className="bg-white shadow-sm">
      <nav className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          {/* Logo and Brand */}
          <div className="flex">
            <div className="flex-shrink-0 flex items-center">
              <h1 className="text-2xl font-bold text-green-600">Energy Efficient Store</h1>
            </div>

            {/* Desktop Navigation */}
            <div className="hidden sm:ml-6 sm:flex sm:space-x-8">
            {['Products', 'Energy Audit', 'Community', 'Education'].map((item) => (
            <a
              key={item}
              href={`/${item.toLowerCase().replace(' ', '-')}`}
              className="border-transparent text-gray-500 hover:border-green-500 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
            >
              {item}
            </a>
          ))}
            </div>
          </div>

          {/* Right side buttons */}
          <div className="flex items-center space-x-4">
            <button className="text-gray-600 hover:text-gray-800 px-3 py-2 rounded-md text-sm font-medium">
              Sign In
            </button>
            <button className="bg-green-500 text-white px-4 py-2 rounded-md text-sm font-medium hover:bg-green-600">
              Get Started
            </button>

            {/* Mobile menu button */}
            <button className="sm:hidden inline-flex items-center justify-center p-2 rounded-md text-gray-400 hover:text-gray-500 hover:bg-gray-100">
              <Menu className="h-6 w-6" />
            </button>
          </div>
        </div>
      </nav>
    </header>
  );
};

export default Header;

----- End of src\components\layout\Header.tsx -----



----- Start of src\components\products\EnergySavingsCard.tsx -----

// src/components/products/EnergySavingsCard.tsx
import React from 'react';

interface EnergySavingsCardProps {
  annualSavings: number;
}

export const EnergySavingsCard: React.FC<EnergySavingsCardProps> = ({ annualSavings }) => {
  return (
    <div className="mt-12 bg-green-50 rounded-lg p-6">
      <h2 className="text-2xl font-bold text-gray-900 mb-4">
        Estimated Energy Savings
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="text-center p-4 bg-white rounded-lg shadow-sm">
          <p className="text-sm text-gray-600 mb-2">Annual Energy Savings</p>
          <p className="text-3xl font-bold text-green-600">${annualSavings}</p>
        </div>
        <div className="text-center p-4 bg-white rounded-lg shadow-sm">
          <p className="text-sm text-gray-600 mb-2">10-Year Savings</p>
          <p className="text-3xl font-bold text-green-600">
            ${annualSavings * 10}
          </p>
        </div>
      </div>
      <p className="mt-4 text-sm text-gray-600">
        *Savings estimates based on average usage patterns. Actual savings may vary.
      </p>
    </div>
  );
};

----- End of src\components\products\EnergySavingsCard.tsx -----



----- Start of src\components\products\ProductDetailHeader.tsx -----

// src/components/products/ProductDetailHeader.tsx
import React from 'react';
import { Product } from '../../../backend/src/types/product';
import { Badge } from '../ui/badge';

interface ProductDetailHeaderProps {
  product: Product;
}

export const ProductDetailHeader: React.FC<ProductDetailHeaderProps> = ({ product }) => {
  return (
    <div className="flex flex-col md:flex-row gap-8">
      <div className="w-full md:w-1/2">
        <img
          src={product.imageUrl}
          alt={product.name}
          className="w-full h-96 object-cover rounded-lg shadow-md"
        />
      </div>

      <div className="w-full md:w-1/2 space-y-4">
        <div className="flex justify-between items-start">
          <h1 className="text-3xl font-bold text-gray-900">{product.name}</h1>
          <Badge variant="outline" className="bg-green-50">
            {product.energyRating}
          </Badge>
        </div>

        <div className="flex items-center space-x-2">
          <span className="text-2xl font-bold text-gray-900">${product.price}</span>
          {product.rebateAmount > 0 && (
            <span className="text-green-600 font-medium">
              ${product.rebateAmount} rebate available
            </span>
          )}
        </div>

        <p className="text-gray-600">{product.description}</p>

        <div className="border-t border-b py-4 space-y-2">
          <div className="flex justify-between">
            <span className="text-gray-600">Brand</span>
            <span className="font-medium">{product.brand}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-600">Model Number</span>
            <span className="font-medium">{product.modelNumber}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-600">Warranty</span>
            <span className="font-medium">{product.warrantyYears} years</span>
          </div>
        </div>

        <a
            href={product.productUrl}
            target="_blank"
            rel="noopener noreferrer"
            className="w-full bg-green-600 text-white py-3 rounded-lg font-medium hover:bg-green-700 text-center"
            >
            View on Retailer Site
            </a>
      </div>
    </div>
  );
};

----- End of src\components\products\ProductDetailHeader.tsx -----



----- Start of src\components\products\ProductSpecifications.tsx -----

// src/components/products/ProductSpecifications.tsx
import React from 'react';

interface ProductSpecificationsProps {
  specifications: Record<string, string | number>;
}

export const ProductSpecifications: React.FC<ProductSpecificationsProps> = ({ specifications }) => {
  return (
    <div className="mt-12">
      <h2 className="text-2xl font-bold text-gray-900 mb-6">Specifications</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {Object.entries(specifications).map(([key, value]) => (
          <div
            key={key}
            className="flex justify-between p-4 bg-gray-50 rounded-lg"
          >
            <span className="text-gray-600">{key}</span>
            <span className="font-medium">{value}</span>
          </div>
        ))}
      </div>
    </div>
  );
};


----- End of src\components\products\ProductSpecifications.tsx -----



----- Start of src\components\ui\alert.tsx -----

// src/components/ui/alert.tsx

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"  // Updated import path

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface AlertProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof alertVariants> {}

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
  ({ className, variant, ...props }, ref) => (
    <div
      ref={ref}
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
)
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

----- End of src\components\ui\alert.tsx -----



----- Start of src\components\ui\badge.tsx -----

// src/components/ui/badge.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

----- End of src\components\ui\badge.tsx -----



----- Start of src\config\api.ts -----

// src/config/api.ts
export const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';

export const API_ENDPOINTS = {
  AUTH: {
    LOGIN: '/auth/login',
    REGISTER: '/auth/register',
    LOGOUT: '/auth/logout',
    PROFILE: '/auth/profile'
  },
  EMAIL: {
    VERIFY: '/email/verify',
    SEND_VERIFICATION: '/email/send-verification'
  },
  PRODUCTS: '/products',
  ENERGY_AUDIT: '/energy-audit'
} as const;

----- End of src\config\api.ts -----



----- Start of src\context\SettingsContext.tsx -----

// src/context/SettingsContext.tsx

import React, { createContext, useContext, useState, useEffect } from 'react';

interface Settings {
  fullName: string;
  email: string;
  phone?: string;
  address?: string;
  emailNotifications: boolean;
  theme: 'light' | 'dark';
}

interface SettingsContextType {
  settings: Settings;
  updateSettings: (newSettings: Partial<Settings>) => Promise<void>;
  isLoading: boolean;
  error: string | null;
}

const SettingsContext = createContext<SettingsContextType | undefined>(undefined);

export const SettingsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [settings, setSettings] = useState<Settings>({
    fullName: '',
    email: '',
    emailNotifications: true,
    theme: 'light'
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchSettings();
  }, []);

  const fetchSettings = async () => {
    setIsLoading(true);
    try {
      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/settings`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      if (!response.ok) throw new Error('Failed to fetch settings');

      const data = await response.json();
      setSettings(data);
      setError(null);

      // Apply theme
      document.documentElement.classList.toggle('dark', data.theme === 'dark');
    } catch (err) {
      setError('Failed to load settings');
    } finally {
      setIsLoading(false);
    }
  };

  const updateSettings = async (newSettings: Partial<Settings>) => {
    setIsLoading(true);
    try {
      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/settings`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify(newSettings)
      });

      if (!response.ok) throw new Error('Failed to update settings');

      const updatedSettings = { ...settings, ...newSettings };
      setSettings(updatedSettings);
      setError(null);

      // Apply theme if it was updated
      if (newSettings.theme) {
        document.documentElement.classList.toggle('dark', newSettings.theme === 'dark');
      }
    } catch (err) {
      setError('Failed to update settings');
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <SettingsContext.Provider value={{ settings, updateSettings, isLoading, error }}>
      {children}
    </SettingsContext.Provider>
  );
};

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (!context) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }
  return context;
};

----- End of src\context\SettingsContext.tsx -----



----- Start of src\hooks\useProducts.ts -----

// src/hooks/useProducts.ts
import { useState, useEffect } from 'react';
import { Product, ProductFilters } from '../../backend/src/types/product';
import ProductDataService from '../../backend/src/services/productDataService';

const productService = new ProductDataService();

export function useProducts() {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [products, setProducts] = useState<Product[]>([]);
  const [categories, setCategories] = useState<{
    main: string[];
    sub: { [key: string]: string[] };
  }>({ main: [], sub: {} });

  useEffect(() => {
    const initializeProducts = async () => {
      try {
        console.log('Starting product initialization...');
        const success = await productService.loadProductsFromCSV('/data/products.csv');
        console.log('Load CSV result:', success);

        if (!success) {
          throw new Error('Failed to load CSV data');
        }

        const prods = await productService.getProducts();
        console.log('Loaded products count:', prods.length);

        const cats = await productService.getCategories();
        console.log('Categories:', cats);

        setProducts(prods);
        setCategories(cats);
        setError(null);
      } catch (err) {
        console.error('Product initialization error:', err);
        setError(err instanceof Error ? err.message : 'An error occurred loading products');
        setProducts([]);
        setCategories({ main: [], sub: {} });
      } finally {
        setIsLoading(false);
      }
    };

    initializeProducts();
  }, []);

  const getFilteredProducts = async (filters?: ProductFilters) => {
    try {
      return await productService.getProducts(filters);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
      return [];
    }
  };

  const getProduct = async (id: string) => {
    try {
      return await productService.getProduct(id);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
      return null;
    }
  };

  return {
    isLoading,
    error,
    products,
    categories,
    getFilteredProducts,
    getProduct
  };
}

----- End of src\hooks\useProducts.ts -----



----- Start of src\lib\utils.ts -----

// src/lib/utils.ts

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

----- End of src\lib\utils.ts -----



----- Start of src\pages\EducationPage.tsx -----

// src/pages/EducationPage.tsx

import React, { useState } from 'react';
import { Search, BookOpen, Video, PieChart, Filter } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';

type ResourceType = 'article' | 'video' | 'infographic';
type ResourceTopic = 'home-appliances' | 'insulation' | 'renewable-energy' | 'energy-management';

interface EducationalResource {
  id: string;
  title: string;
  description: string;
  type: ResourceType;
  topic: ResourceTopic;
  readTime?: string;
  thumbnail: string;
  url: string;
  datePublished: string;
}

const EducationPage = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedType, setSelectedType] = useState<ResourceType | 'all'>('all');
  const [selectedTopic, setSelectedTopic] = useState<ResourceTopic | 'all'>('all');

  // This would typically come from an API
  const resources: EducationalResource[] = [
    {
      id: '1',
      title: 'Understanding Home Energy Efficiency',
      description: 'A comprehensive guide to making your home more energy efficient.',
      type: 'article',
      topic: 'home-appliances',
      readTime: '5 min read',
      thumbnail: '/api/placeholder/400/250',
      url: '/education/understanding-home-energy-efficiency',
      datePublished: '2024-01-15'
    },
    // Additional resources would be loaded from backend
  ];

  const getResourceIcon = (type: ResourceType) => {
    switch (type) {
      case 'article':
        return <BookOpen className="h-5 w-5 text-blue-500" />;
      case 'video':
        return <Video className="h-5 w-5 text-red-500" />;
      case 'infographic':
        return <PieChart className="h-5 w-5 text-green-500" />;
    }
  };

  const filteredResources = resources.filter(resource => {
    const matchesSearch = resource.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         resource.description.toLowerCase().includes(searchQuery.toLowerCase());
    const matchesType = selectedType === 'all' || resource.type === selectedType;
    const matchesTopic = selectedTopic === 'all' || resource.topic === selectedTopic;
    return matchesSearch && matchesType && matchesTopic;
  });

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Header Section */}
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-900">Educational Resources</h1>
          <p className="mt-4 text-lg text-gray-600">
            Learn about energy efficiency and discover ways to reduce your energy consumption
          </p>
        </div>

        {/* Search and Filter Section */}
        <div className="bg-white rounded-lg shadow-sm p-4 mb-8">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Search Input */}
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
              <input
                type="text"
                placeholder="Search resources..."
                className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
            </div>

            {/* Type Filter */}
            <select
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
              value={selectedType}
              onChange={(e) => setSelectedType(e.target.value as ResourceType | 'all')}
            >
              <option value="all">All Types</option>
              <option value="article">Articles</option>
              <option value="video">Videos</option>
              <option value="infographic">Infographics</option>
            </select>

            {/* Topic Filter */}
            <select
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
              value={selectedTopic}
              onChange={(e) => setSelectedTopic(e.target.value as ResourceTopic | 'all')}
            >
              <option value="all">All Topics</option>
              <option value="home-appliances">Home Appliances</option>
              <option value="insulation">Insulation</option>
              <option value="renewable-energy">Renewable Energy</option>
              <option value="energy-management">Energy Management</option>
            </select>
          </div>
        </div>

        {/* Resources Grid */}
        {filteredResources.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {filteredResources.map((resource) => (
              <div key={resource.id} className="bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow duration-200">
                <img
                  src={resource.thumbnail}
                  alt={resource.title}
                  className="w-full h-48 object-cover rounded-t-lg"
                />
                <div className="p-4">
                  <div className="flex items-center gap-2 mb-2">
                    {getResourceIcon(resource.type)}
                    <Badge variant="outline" className="text-xs">
                      {resource.topic.replace('-', ' ').toUpperCase()}
                    </Badge>
                    {resource.readTime && (
                      <span className="text-xs text-gray-500">{resource.readTime}</span>
                    )}
                  </div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-2">
                    {resource.title}
                  </h3>
                  <p className="text-sm text-gray-600 mb-4">
                    {resource.description}
                  </p>
                  <a
                    href={resource.url}
                    className="text-green-600 hover:text-green-700 font-medium text-sm"
                  >
                    Learn More →
                  </a>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <Alert>
            <AlertDescription>
              No resources found matching your search criteria. Try adjusting your filters.
            </AlertDescription>
          </Alert>
        )}
      </div>
    </div>
  );
};

export default EducationPage;

----- End of src\pages\EducationPage.tsx -----



----- Start of src\pages\EnergyAuditPage.tsx -----

// src/pages/EnergyAuditPage.tsx

import React from 'react';
import EnergyAuditForm from '../components/audit/EnergyAuditForm';

const EnergyAuditPage = () => {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-900">DIY Energy Audit</h1>
          <p className="mt-4 text-lg text-gray-600">
            Complete our comprehensive energy audit to receive personalized recommendations
            for improving your home's energy efficiency.
          </p>
        </div>

        <EnergyAuditForm />
      </div>
    </div>
  );
};

export default EnergyAuditPage;

----- End of src\pages\EnergyAuditPage.tsx -----



----- Start of src\pages\ProductDetailPage.tsx -----

// src/pages/ProductDetailPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import { ArrowLeft, FileDown, Loader2 } from 'lucide-react';
import { Alert, AlertDescription } from '../components/ui/alert';
import { ProductDetailHeader } from '../components/products/ProductDetailHeader';
import { ProductSpecifications } from '../components/products/ProductSpecifications';
import { EnergySavingsCard } from '../components/products/EnergySavingsCard';
import { useProducts } from '../hooks/useProducts';
import { Product } from '../../backend/src/types/product';

const ProductDetailPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const { getProduct, isLoading } = useProducts();
  const [product, setProduct] = useState<Product | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadProduct = async () => {
      try {
        if (!id) throw new Error('Product ID is required');
        const productData = await getProduct(id);
        if (!productData) throw new Error('Product not found');
        setProduct(productData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load product');
      }
    };

    loadProduct();
  }, [id, getProduct]);

  if (isLoading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loader2 className="h-8 w-8 animate-spin text-green-600" />
      </div>
    );
  }

  if (error || !product) {
    return (
      <div className="max-w-7xl mx-auto px-4 py-8">
        <Alert variant="destructive">
          <AlertDescription>{error || 'Product not found'}</AlertDescription>
        </Alert>
      </div>
    );
  }

  // Calculate estimated savings
  // This is a placeholder calculation - adjust based on actual energy efficiency data
  const estimatedAnnualSavings = Math.round(
    parseFloat(product.efficiency.replace(/[^\d.]/g, '')) * 100
  );

  return (
    <div className="max-w-7xl mx-auto px-4 py-8">
      {/* Back Navigation */}
      <div className="mb-6">
        <Link
          to="/products"
          className="inline-flex items-center text-green-600 hover:text-green-700"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Products
        </Link>
      </div>

      {/* Main Product Content */}
      <div className="bg-white rounded-lg shadow-sm p-6">
        <ProductDetailHeader product={product} />

        {/* Features Section */}
        <div className="mt-12">
          <h2 className="text-2xl font-bold text-gray-900 mb-6">Features</h2>
          <ul className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {product.features.map((feature, index) => (
              <li key={index} className="flex items-start">
                <span className="text-green-500 mr-2">•</span>
                <span className="text-gray-600">{feature}</span>
              </li>
            ))}
          </ul>
        </div>

        {/* Specifications */}
        <ProductSpecifications specifications={product.specifications} />

        {/* Energy Savings Estimate */}
        <EnergySavingsCard annualSavings={estimatedAnnualSavings} />

        {/* Additional Resources */}
        <div className="mt-12">
          <h2 className="text-2xl font-bold text-gray-900 mb-6">Additional Resources</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {product.pdfUrl && (
              <a
                href={product.pdfUrl}
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center p-4 bg-gray-50 rounded-lg hover:bg-gray-100"
              >
                <FileDown className="h-6 w-6 text-green-600 mr-3" />
                <div>
                  <p className="font-medium text-gray-900">Product Specification Sheet</p>
                  <p className="text-sm text-gray-500">Download detailed specifications (PDF)</p>
                </div>
              </a>
            )}

            <a
              href={product.productUrl}
              target="_blank"
              rel="noopener noreferrer"
              className="flex items-center p-4 bg-gray-50 rounded-lg hover:bg-gray-100"
            >
              <div>
                <p className="font-medium text-gray-900">ENERGY STAR Product Details</p>
                <p className="text-sm text-gray-500">View complete product information</p>
              </div>
            </a>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ProductDetailPage;

----- End of src\pages\ProductDetailPage.tsx -----



----- Start of src\pages\ProductsPage.tsx -----

// src/pages/ProductsPage.tsx
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { Search, Sliders } from 'lucide-react';
import { useProducts } from '../hooks/useProducts';
import { Product, ProductFilters } from '../../backend/src/types/product';
import { Badge } from '../components/ui/badge';

const ProductsPage: React.FC = () => {
  const { isLoading, error, categories, getFilteredProducts } = useProducts();
  const [products, setProducts] = useState<Product[]>([]);
  const [filters, setFilters] = useState<ProductFilters>({
    mainCategory: '',
    subCategory: '',
    search: '',
    efficiency: ''
  });

  useEffect(() => {
    loadProducts();
  }, [filters]);

  const loadProducts = async () => {
    const filteredProducts = await getFilteredProducts(filters);
    setProducts(filteredProducts);
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-500"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="max-w-7xl mx-auto px-4 py-8">
        <div className="bg-red-50 text-red-600 p-4 rounded-lg">
          Error: {error}
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      {/* Page Header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900">Energy Efficient Products</h1>
        <p className="mt-2 text-gray-600">
          Browse our selection of ENERGY STAR® certified products
        </p>
      </div>

      {/* Search and Filter Section */}
      <div className="mb-8 grid grid-cols-1 md:grid-cols-4 gap-4">
        {/* Search Bar */}
        <div className="md:col-span-2">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <input
              type="text"
              placeholder="Search products..."
              className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
              value={filters.search}
              onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
            />
          </div>
        </div>

        {/* Category Filter */}
        <div>
          <select
            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
            value={filters.mainCategory}
            onChange={(e) => setFilters(prev => ({
              ...prev,
              mainCategory: e.target.value,
              subCategory: '' // Reset sub-category when main category changes
            }))}
          >
            <option value="">All Categories</option>
            {categories.main.map((category) => (
              <option key={category} value={category}>{category}</option>
            ))}
          </select>
        </div>

        {/* Sub-Category Filter */}
        <div>
          <select
            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
            value={filters.subCategory}
            onChange={(e) => setFilters(prev => ({ ...prev, subCategory: e.target.value }))}
            disabled={!filters.mainCategory}
          >
            <option value="">All Sub-Categories</option>
            {filters.mainCategory && categories.sub[filters.mainCategory]?.map((subCategory) => (
              <option key={subCategory} value={subCategory}>{subCategory}</option>
            ))}
          </select>
        </div>
      </div>

      {/* Product Grid */}
      <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {products.map((product) => (
          <div key={product.id} className="bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow duration-200">
            <div className="p-4">
              <div className="flex justify-between items-start mb-2">
                <h3 className="text-lg font-medium text-gray-900">{product.name}</h3>
                <Badge variant="outline" className="bg-green-50">
                  ENERGY STAR
                </Badge>
              </div>
              <p className="text-sm text-gray-500 mb-4">Model: {product.model}</p>

              <div className="mb-4">
                {Object.entries(product.specifications).slice(0, 2).map(([key, value]) => (
                  <div key={key} className="text-sm">
                    <span className="text-gray-600">{key}:</span>{' '}
                    <span className="text-gray-900">{value}</span>
                  </div>
                ))}
              </div>

              <div className="flex justify-between items-center">
                <Link
                  to={`/products/${product.id}`}
                  className="text-green-600 hover:text-green-700 font-medium"
                >
                  View Details
                </Link>
                <a
                  href={product.productUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="bg-green-100 text-green-700 px-4 py-2 rounded-md text-sm font-medium hover:bg-green-200 transition-colors duration-200"
                >
                  View on Site
                </a>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* No Results Message */}
      {products.length === 0 && (
        <div className="text-center py-12">
          <p className="text-gray-500">No products found matching your criteria.</p>
        </div>
      )}
    </div>
  );
};

export default ProductsPage;

----- End of src\pages\ProductsPage.tsx -----



----- Start of src\pages\UserSettingsPage.tsx -----

// src/pages/UserSettingsPage.tsx

import React, { useState, useEffect } from 'react';
import { Alert, AlertDescription } from '../components/ui/alert';

const UserSettingsPage = () => {
  const [settings, setSettings] = useState({
    fullName: '',
    email: '',
    phone: '',
    address: '',
    emailNotifications: true,
    theme: 'light'
  });

  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [deletePassword, setDeletePassword] = useState('');

  useEffect(() => {
    fetchSettings();
  }, []);

  const fetchSettings = async () => {
    try {
      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/settings`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      if (!response.ok) throw new Error('Failed to fetch settings');

      const data = await response.json();
      setSettings(data);
    } catch (err) {
      setError('Failed to load settings');
    }
  };

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setSettings(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    setIsLoading(true);

    try {
      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/settings`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify(settings)
      });

      if (!response.ok) throw new Error('Failed to update settings');

      setSuccess('Settings updated successfully');
    } catch (err) {
      setError('Failed to update settings');
    } finally {
      setIsLoading(false);
    }
  };

  const handleExportData = async () => {
    try {
      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/settings/export`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      if (!response.ok) throw new Error('Failed to export data');

      const data = await response.json();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'user-data.json';
      a.click();
    } catch (err) {
      setError('Failed to export data');
    }
  };

  const handleDeleteAccount = async () => {
    try {
      const response = await fetch(`${process.env.REACT_APP_API_URL}/api/settings`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify({ password: deletePassword })
      });

      if (!response.ok) throw new Error('Failed to delete account');

      localStorage.clear();
      window.location.href = '/';
    } catch (err) {
      setError('Failed to delete account');
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">Account Settings</h1>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {success && (
        <Alert className="mb-6 bg-green-50">
          <AlertDescription>{success}</AlertDescription>
        </Alert>
      )}

      <form onSubmit={handleSubmit} className="space-y-6">
        <div>
          <label htmlFor="fullName" className="block text-sm font-medium text-gray-700">
            Full Name
          </label>
          <input
            type="text"
            id="fullName"
            name="fullName"
            value={settings.fullName}
            onChange={handleInputChange}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
          />
        </div>

        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            Email
          </label>
          <input
            type="email"
            id="email"
            name="email"
            value={settings.email}
            disabled
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-gray-50"
          />
        </div>

        <div>
          <label htmlFor="phone" className="block text-sm font-medium text-gray-700">
            Phone
          </label>
          <input
            type="tel"
            id="phone"
            name="phone"
            value={settings.phone}
            onChange={handleInputChange}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
          />
        </div>

        <div>
          <label htmlFor="address" className="block text-sm font-medium text-gray-700">
            Address
          </label>
          <textarea
            id="address"
            name="address"
            value={settings.address}
            onChange={handleInputChange}
            rows={3}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
          />
        </div>

        <div className="flex items-center">
          <input
            type="checkbox"
            id="emailNotifications"
            name="emailNotifications"
            checked={settings.emailNotifications}
            onChange={handleInputChange}
            className="h-4 w-4 text-green-600 focus:ring-green-500 border-gray-300 rounded"
          />
          <label htmlFor="emailNotifications" className="ml-2 block text-sm text-gray-900">
            Receive email notifications
          </label>
        </div>

        <div>
          <label htmlFor="theme" className="block text-sm font-medium text-gray-700">
            Theme
          </label>
          <select
            id="theme"
            name="theme"
            value={settings.theme}
            onChange={handleInputChange}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-green-500 focus:border-green-500"
          >
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </div>

        <div className="flex justify-between pt-6">
          <button
            type="submit"
            disabled={isLoading}
            className="inline-flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-50"
          >
            {isLoading ? 'Saving...' : 'Save Changes'}
          </button>

          <button
            type="button"
            onClick={handleExportData}
            className="inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
          >
            Export Data
          </button>
        </div>
      </form>

      <div className="mt-12 border-t pt-6">
        <h2 className="text-lg font-medium text-red-600 mb-4">Danger Zone</h2>

        {!showDeleteConfirm ? (
          <button
            onClick={() => setShowDeleteConfirm(true)}
            className="inline-flex justify-center py-2 px-4 border border-red-600 rounded-md shadow-sm text-sm font-medium text-red-600 bg-white hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
          >
            Delete Account
          </button>
        ) : (
          <div className="space-y-4">
            <p className="text-sm text-gray-600">
              Please enter your password to confirm account deletion. This action cannot be undone.
            </p>
            <input
              type="password"
              value={deletePassword}
              onChange={(e) => setDeletePassword(e.target.value)}
              placeholder="Enter password"
              className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-red-500 focus:border-red-500"
            />
            <div className="flex space-x-4">
              <button
                onClick={handleDeleteAccount}
                className="inline-flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
              >
                Confirm Deletion
              </button>
              <button
                onClick={() => {
                  setShowDeleteConfirm(false);
                  setDeletePassword('');
                }}
                className="inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
              >
                Cancel
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default UserSettingsPage;

----- End of src\pages\UserSettingsPage.tsx -----



----- Start of src\templates\email-verification.html -----

<!-- src/templates/email/email-verification.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verify Your Email</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
        }
        .header {
            background-color: #4CAF50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
            background-color: #fff;
        }
        .button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            margin: 20px 0;
        }
        .footer {
            text-align: center;
            padding: 20px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Verify Your Email Address</h1>
        </div>
        <div class="content">
            <p>Hi {{name}},</p>
            <p>Welcome to Energy Efficient Store! Please verify your email address by clicking the button below:</p>
            <p style="text-align: center;">
                <a href="{{verificationLink}}" class="button">Verify Email Address</a>
            </p>
            <p>This verification link will expire in {{expiryHours}} hours.</p>
            <p>If you did not create an account with us, please ignore this email.</p>
            <p>If you're having trouble clicking the button, copy and paste this URL into your browser:</p>
            <p style="word-break: break-all; font-size: 12px;">{{verificationLink}}</p>
        </div>
        <div class="footer">
            <p>This email was sent by Energy Efficient Store</p>
            <p>© {{year}} Energy Efficient Store. All rights reserved.</p>
        </div>
    </div>
</body>
</html>

----- End of src\templates\email-verification.html -----

